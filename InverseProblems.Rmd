---
title: "Inverse Problems in Experimental Particle Physics"
author: "Sean Gilligan"
output: 
  pdf_document:
    citation_package: biblatex
    number_sections: TRUE
keep_tex: TRUE
bibliography: citations.bib
header-includes:
  - \usepackage{setspace}\onehalfspacing
  - \usepackage{xcolor}
  - \usepackage{bm}
  - \usepackage{amsmath}
  - \usepackage{parskip}
  - \usepackage{hyperref}
  - \usepackage{csquotes}
  - \usepackage{float}
  - \usepackage{wrapfig}
  - \hypersetup{colorlinks=TRUE,linkcolor=red,citecolor=blue,filecolor=magenta,urlcolor=blue}
  - \newcommand{\comment}[1]{}
abstract: \singlespacing This report provides a survey of some of the common methods used by the high energy physics community to understand and solve ill-posed inverse problems as they pertain to signal distortions that result from imperfect measuring devices and processes. These methods are in general collectively referred to as unfolding. The specifics of data and data collection methods are generalized. Common features are discussed insofar as they contribute to the necessary understanding of the data and implementation of any covered unfolding methods. In order to construct a slightly more wholistic picture some additional topics are briefly touched upon if they relate to other common aspects of data analysis in particle physics, but only during parts of relevant discussions where they would otherwise normally appear.
fontsize: 12pt
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```

```{r, message = F, echo=F}
library(tidyverse)
library(gridExtra)
library(grid)
library(gridtext)
library(gtable)
library(knitr)
library(RColorBrewer)
library(viridisLite)
library(viridis)
library(gtools)
library(cowplot)
library(egg)
library(scales)
library(ggforce)
```

\section{Introduction}
A common problem faced in the quantitative sciences and their associated technologies is the introduction of errors during the data collection process. While the possible sources of these errors are as varied as the possible events which the data might describe, significant work has been done to develop methods the can help would-be analysts reconcile them. The requisite understanding of a scenario's underlying systematic and stochastic processes might not allow researchers to truly reverse entropy or make up for the finite resolution of a detector, but it can approximate them with a quantifiable degree of certainty. The applied mathematics that this involves falls within the general category of \textbf{inverse problems}, and there are a variety of labels used to refer to the procedures in its arsenal. Within the applications described here there is the colloquially vague \textbf{unsmearing}, but there are also names that reference specific applications and methods, such as those characterized in this report.

For the sake of simplicity, the manner of inverse problems addressed here will only involve linear operations that map from one Hilbert space\footnote{The definition of a Hilbert space is provided in Appendix \ref{appHilbert} for convenience.} to another. Symbolically this can be expressed by the equation
\begin{align}
Az=u,\nonumber
\end{align}
where $A$ is a linear operator acting on an element $z\in Z$, the sought solution, to produce an element $u\in U$, the observed data. Within the context of the methods described herein $z$ and $u$ take the form of continuous or discrete distributions that when integrated or summed over the domain of their arguments result in finite real quantities.

The difficulty of solving for $z$ can be nominally classified into one of two camps. The easiest cases involve conditions that create a \textbf{well-posed} problem, which requires that \cite{Yagola2011ch2}
\begin{enumerate}
  \item a solution exists $\forall u\in U$,
  \item the solution is unique,
  \item and if $u_n\longrightarrow u$, $Az_n\longrightarrow u_n$, and $Az\longrightarrow u$, then $z_n\longrightarrow z$.
\end{enumerate}
Conditions 1 and 2 work together to imply that the inverse operator $A^{-1}$ exists, and Condition 3 is often worded to describe the inverse as continuous, which means that small deviations in $u$ should correspond to similarly small deviations in $z$. When one or more of these conditions are not meant, the problem is said to be \textbf{ill-posed}, and some of the consequences of assuming otherwise should hopefully become clear in the coming pages. Entire books have been written on this subject that do not begin to cover the full scope of the methods developed to deal with ill-posed problems. The hope of this paper is for it to serve as an introduction to this content and provide some degree of direction for those who would like to know more. In the next section convolutions and deconvolutions are discussed in some detail for the continuous case before generalizing and shifting over to discrete approaches that allow for the better use of computational methods.

\subsection{The Deconvolution}

One way to characterize a basic example of a situation suitable for being treated as a convolution would be the following. Assume that data collected regarding $n$ statistical events represent the measurement of $n$ independent and identically distributed (i.i.d.) random variables $\bm{X}=\{X_1,X_2,\dots,X_n\}$ from a distribution of possible values represented by the probability density function (PDF) $f_X(x)$, such that the probability of a random variable $X_i$ having a value between $x_a$ and $x_b$ is $$P(\:x_a<X_i<x_b\:)=\int_{x_a}^{x_b}f(x)\,dx$$ and $$\int_\mathcal{X}f(x)\,dx=1,$$ where $\mathcal{X}$ represents the domain of $x$. The error introduced during the measurement process is similarly represented by a set of i.i.d. random variables $\bm{\varepsilon}=\{\varepsilon_1,\varepsilon_2,\dots,\varepsilon_n\}$ with a PDF $f_\varepsilon(\varepsilon)$, where the sets $\bm{\varepsilon}$ and $\bm{X}$ are typically assumed to be independent of each other. The set of measured/reconstructed values $\bm{Y}=\{Y_1,Y_2,\dots,Y_n\}$ then are also i.i.d. and can be defined in terms of the preceding sets of variables such that for event $i\in\{1,\dots,n\}$, 
\begin{align}Y_i&=g(X_i,\varepsilon_i)\nonumber\\&=X_i+\varepsilon_i.\label{eq:meas}\end{align} 
In light of this relationship, the corresponding PDF $f_Y(y)$ can be found explicitly through an operation on $f_X(x)$ and $f_\varepsilon(\varepsilon)$ using the mathematics of functional analysis. Stated in more general terms, the empirical density function $f_Y$ is formed from the \textbf{convolution} of the true density function $f_X$ and the error density function $f_\varepsilon$, and is defined by \cite{Panaretos2011} \begin{align}f_Y&\equiv f_X*f_\varepsilon\label{eq:conv1}\\f_Y(y)&\equiv\int_\mathcal{X}f_X(x)f_\varepsilon(\varepsilon)\,dx\nonumber\\&=\int_\mathcal{X}f_X(x)f_\varepsilon\big(g_x^{-1}(y)\big)\left\vert J_{g_x^{-1}}(y)\right\vert dx\nonumber\\&=\int_\mathcal{X}f_X(x)f_\varepsilon(y-x)\,dx,\label{eq:conv2}\end{align}
where $J$ represents the Jacobian of the transformation involved in performing the change of basis on $f_\varepsilon$ from $\varepsilon$ to $x$, which is necessary for the evaluation of the integral for a given $y$. The magnitude of the Jacobian for transformation of $\varepsilon$ to $y-x$ through the manipulation of Equation \eqref{eq:meas} happens to be $1$.

As the collection of measured values $\bm{Y}$ accumulates an estimate of empirical density $\hat{f}_Y$ can readily be formed. However, a major goal in an analysis of data like this is typically to develop an accurate estimate of the true density $\hat{f}_X$. Using the information contained in $\hat{f}_Y$ to accomplish this necessarily requires some attempt at finding an inverse process to the convolution, i.e. the \textbf{deconvolution}.

For cases in the form of this particular example there are a variety approaches, but they commonly involve the Fourier transform of the density functions $\left\{f_X,f_\varepsilon,f_Y\right\}$ into their corresponding characteristic functions $\left\{\phi_X,\phi_\varepsilon,\phi_Y\right\}$ \cite{Meister2009}\cite{Panaretos2011}. Minor aspects of the definition for the Fourier transform can vary slightly between applications, resulting primarily from the use of different scale factors and sign conventions. Here it will be defined for some random variable $U\in\mathbb{R}$ with density function $f_U(u)$ and random variable $T\in\mathbb{R}$ as \begin{align}\phi_T(t)=\int_{-\infty}^\infty f_U(u)\,e^{itu}\,du.\label{eq:ft}\end{align} When conditions permit the inverse Fourier transform can be found via \begin{align}f_U(u)=\int_{-\infty}^\infty \phi_T(t)\,e^{-itu}\,dt.\label{eq:ift}\end{align} The Fourier transform is important in deconvolution methods because when you apply it to the convolution of two density functions the link between their respective characteristic functions becomes purely multiplicative, i.e.
$$f_Y=f_X*f_\varepsilon\implies\phi_Y=\phi_X\phi_\varepsilon.$$
An instructional proof of this result is provided on page 447 of \cite{Boas2005}.

\subsection{Generalizing}

The remainder of this paper is dedicated to characterizing the major methods adopted by the High Energy Physics (HEP) community toward solving their inverse problems. While most literature on deconvolution methods do use the word "convolution", this operation is also referred to by the German word \textit{faltung} \cite{Weisstein}. The latter's English translation, \textbf{folding}, is featured prominently in the particle physics community, but refers to a more generalized process than what is described by Equation \eqref{eq:conv2} \cite{DAgostini1994}\cite{Adye2011}\cite{Blobel2013}. In general, the terms folding and \textbf{unfolding} are used to describe two supersets of processes that respectively include convolution and deconvolution.

One way to arrive at the intended generalization is with the help of conditional probability. Thinking of $\{X,Y\}$ as a continuous bivariate random vector with joint PDF $f(x,y)$ and marginal PDFs $f_X(x)$ and $f_Y(y)$, we can define the conditional PDF of $Y$ given that $X=x$ as function of $y$, $f(y\,\vert x)$ \cite{Casella2001}. The relationship between these PDFs is sufficient to define any one of them in terms of operations involving one or more of the others. As such, for $f_Y(y)$ it can be shown
\begin{align}f_Y(y)&=\int_\mathcal{X}f(x,y)\,dx\nonumber\\&=\int_\mathcal{X}f(y\,\vert x)f_X(x)\,dx\nonumber\\&=\int_\mathcal{X}K(x,y)f_X(x)\,dx.\label{eq:fred}\end{align}
While integrating over $x$, $f(y\,\vert x)$ is implicitly treated a function of both $x$ and $y$. Acknowledging this allows for understanding Equation \eqref{eq:fred} as a Fredholm integral of the first kind with a Kernel function $K(x,y)$ reflecting the physical measurement process \cite{Blobel2011}. The relationship between $x$ and $y$ in $K(x,y)$ is not defined, but when the kernel is a function of the difference of its arguments, such that $K(x,y)=K(y-x)$, Equation \eqref{eq:fred} becomes the convolution described in Equation \eqref{eq:conv2}.

In particle physics experiments, analysts make use of Monte-Carlo (MC) simulations to estimate detector response to randoms samples from some true distribution $f_X(x)^{\text{MC}}$, which is itself estimated by way of MC simulations using models that typically contain theory being tested by the experiment in question. The resulting measured distribution $f_Y(y)^{\text{MC}}$ grants implicit knowledge of $K(x,y)$ by way of Equation \eqref{eq:fred} \cite{Blobel2013}. Finding the inverse of this Kernel is then the goal, as it should in theory allow for the mapping of experimental observations $\bm Y$, as randomly sampled from $f_Y(y)$, back to their true values $\bm X$.

\subsection{Discretization}

In practice researchers are only ever dealing with estimates $\hat f_X$, $\hat f_Y$, $\hat f_X^{\text{MC}}$, and $\hat f_Y^{\text{MC}}$, and the sets of data that contribute to these estimates are organized by bin into histograms that form unnormalized granular approximations of the true distributions. Thinking in terms of these histograms allows for the reformulation of Equation \eqref{eq:fred} into the linear matrix equation:
\begin{align}\bm\nu = \bm{R}\bm\mu.\label{eq:mat}\end{align}
The vectors $\bm\nu$, $\bm\mu$ and matrix $\bm{K}$ are mapped from their continuous counterparts by \cite{Blobel2013}:
\begin{align}
  \text{true distribution }f_X(x)&\longrightarrow\bm\mu\,\in\,\mathbb{R}^N_{+}\cup\bm{0}\text{ the unknown true bin counts,}\nonumber\\
  \text{measured distribution }f_Y(y)&\longrightarrow\bm\nu\,\in\,\mathbb{R}^M_{+}\cup\bm{0}\text{ the measured bin counts,}\nonumber\\
  \text{Kernel }K(x,y)&\longrightarrow\bm{R}\;\;\text{rectangular }M\text{-by-}N\text{ \bf response matrix}\text{.}\nonumber
\end{align}
The components of vectors $\bm\nu$ and $\bm\mu$ represent the number of events that have occurred within the regions of $x$ and $y$ that define the components' corresponding bins. For $i=1,\dots,M$ and $j=1,\dots,N$ the components of matrix $\bm R$ are defined by the conditional probability \cite{Cowan1998}
\begin{align}
  R_{ij}&=P(\text{measured value in bin }i\vert\text{true value in bin }j)\nonumber\\
        &=\frac{P(\text{measured value in bin }i\text{ and true value in bin }j)}{P(\text{true value in bin }j)}\nonumber\\
        &=\frac{\int_{\text{bin }i}\int_{\text{bin }j}K(x,y)f_X(x)dx\,dy}{\int_{\text{bin }j}dx\,f_X(x)}\nonumber\\
        &\equiv P(\nu_i\vert\mu_j).\label{eq:Rij}
\end{align}
In terms of $P(\nu_i\vert\mu_j)$ the full response matrix then has the form
\begin{align}
  \bm{R}=\begin{pmatrix}
    P(\nu_1\vert\mu_1)     & P(\nu_1\vert\mu_2)     & \dots  & P(\nu_1\vert\mu_{N})   \\
    P(\nu_2\vert\mu_1)     & P(\nu_2\vert\mu_2)     & \cdots & P(\nu_2\vert\mu_{N})   \\
    \vdots                 & \vdots                 & \ddots & \vdots                 \\
    P(\nu_{M}\vert\mu_1)   & P(\nu_{M}\vert\mu_2)   & \dots  & P(\nu_{M}\vert\mu_{N})
  \end{pmatrix}.\label{eq:Rmat}
\end{align}
With these definitions Equation \eqref{eq:mat} tells us that an event produced in bin $\mu_j$ has some probability $\geq 0$ of being measured in each of the $M$ bins of $\bm\nu$, and that each bin count $\nu_i$ receives potential contributions from each of the $N$ bins in $\bm\mu$, i.e. 
\begin{align}\nu_i = \sum_{j=1}^NR_{ij}\mu_j.\label{eq:bini}\end{align}
The number of bins are typically set such that $N\leq M$, with the convention $M=N+1$ being common. A higher number of bins in the measured distribution reflects that the measuring process is expected to map some events in $\bm X$ to values of $\bm Y$ that are outside the region of values that define the initial $N$ bins. These one or more extra bins are intended to account for all the possible values that a particular event could be mapped to, such that for a given event starting in bin $j$ one might expect the probabilities of it being measured in each of the $M$ final bins to sum to $1$. 

However, in practice there are a variety of constraints on events that can either result in them not being included for analysis or even prevent them from being detected at all. For example, an analyst might cut events observed in regions of a detector that result in insufficient data collection, or maybe some event information carriers miss the detector entirely, resulting in such events going unseen. In either case the effect of these missing events is described using the detector \textbf{efficiency}, and represented mathematically by the $M$-vector $\bm\epsilon$, where component $\epsilon_j$ is the efficiency of the $j$th true bin defined\footnote{In the continuous case it is typically written as $\epsilon(x)$, and understood to be the conditional probability of an event producing any measured value given it has a true value of $x$. It is typically absorbed into $K(x,y)$ where it goes on to manifest within $\bm R$ in the manner shown in Equation \eqref{eq:eff} \cite{Blobel2013}.} by \cite{Cowan1998}:
\begin{align}\sum_{i=1}^{M}P(\nu_i\vert\mu_j)=\sum_{i=1}^{M}R_{ij}=\epsilon_j\leq 1.\label{eq:eff}\end{align}
In contrast to this are contributions to measured counts from \textbf{background} processes, which are typically studied separately and not involved directly in the unfolding process. Ignoring it would be a major omission in any description of HEP data, so it is briefly included here for completion. Mathematically it is included by modifying Equation \eqref{eq:bini} to read
\begin{align}\nu_i = \sum_{j=1}^NR_{ij}\mu_j+\beta_i,\end{align}
where $\beta_i$ is the $i$th component of the $M$-vector $\bm\beta$, which represents the binned background counts. This leads to equations like $\nu_i^{\text{sig}}=\nu_i-\beta_i$ in order to specify the expected number of measured counts that are from the signal of interest. Going forward background will be assumed to already have been accounted for, and $\nu_i$ will refer to the measured signal counts of bin $i$.

As all these variables so far have been derived from the exact continuous distributions $f_X(x)$ and $f_Y(y)$, they correspond to the expectation values that researchers are estimating during data collection and analysis. As this is a counting process the components of the observed number of signal events $\bm{n}$, an $M$-vector, are often related to the components of the expected number of observed counts $\bm\nu$ as a collection of $M$ separate and independent Poisson processes. That is to say the observed counts $n_i$ in bin $i$ are treated as i.i.d. random variables with the probability mass function
\begin{align}P(n_i\vert\nu_i)=\frac{\nu_i^{n_i}e^{-\nu_i}}{n_i!}.\label{eq:pois}\end{align}
The counts $n_i$ would in theory then form the estimate $\hat\nu_i$ of the expected counts $\nu_i$ by
\begin{align}\nu_i&=\text{E}[\hat\nu_i]=\text{E}[n_i]\nonumber\\&=\text{Var}[\hat\nu_i]=\text{Var}[n_i].\nonumber\end{align}
Understanding the probability distribution of $\bm{n}$ allows for unfolding methods that involve the use of maximum likelihood estimation. For methods based on least squares it becomes necessary to find the covariance matrix $\bm{V}$ of the observations, which for independent Poisson processes has components of the form
\begin{align}V_{ij}&=\text{Cov}[n_i,n_j]\nonumber\\&=\delta_{ij}\nu_i,\label{eq:cov}\end{align}
where $\delta_{ij}$ is the Kronecker delta\footnote{The Kronecker delta $\delta_{ij}$ is a piecewise function of variables $i$ and $j$ defined by $\delta_{ij}=\begin{cases}0\;\;\;\text{if }i\neq j\\1\;\;\;\text{if }i=j\end{cases}.$}.

\subsection{A Simulated Example}

Consider an example of the form described by Equation \eqref{eq:meas}, i.e. $Y_i=\epsilon_i\left(X_i+\varepsilon_i\right)$. Let $X_i$ be a i.i.d. random variable from a bimodal distribution of the form $X_i=Z_iX_{1,i}+(1-Z_i)X_{2,i}$, where
\begin{align}
  X_{1,i}&\sim \text{Gamma}(24,0.4),\nonumber\\
  X_{2,i}&\sim \text{Gamma}(42,0.4),\nonumber\\
  \text{and }Z_i&\sim\text{Bernoulli}(2/7),\nonumber
\end{align}
and let the effects of detector smearing be represented by i.i.d random variables generated by the conditional Gaussian process $\varepsilon_i\sim N\left(\mu(X_i),\sigma(X_i)^2\right)$, the mean and variance of which are functions defined by
\begin{align}
  \mu(X_i=x)&=-x^{1/4}\;\;\text{and}\nonumber\\
  \sigma(X_i=x)&=\log\left(\frac{x+10}{4}\right).\nonumber
\end{align}
The efficiency is similarly conditional on $X_i$, and is modeled here as a Bernoulli process with i.i.d random variables $\epsilon_i\sim\text{Bernoulli}\big(p(X_i)\big)$, where the average detection rate (when $\epsilon_i=1$) is a function of the form
\begin{align}
  p(X_i=x)=1-e^{-\sqrt{x}/4}.\nonumber
\end{align}

```{r, echo = F}
set.seed(12321)
# Assume 10000 events
nsim_data <- 20000
dmrat <- 20
nsim_mc <- dmrat*nsim_data

# Two possible types of processes with different means but equal variances
loctn <- c(11,18,14)
scale <- c(4,4,5)
p <- 0.25
p1 <- c(0.3,0.7)
p2 <- c((1-p)*p1[1],(1-p)*p1[2],p)
p3 <- p2 + c(-0.04,0.03,0.01)

events_data1 <- c(rmultinom(1, nsim_data, p1))
events_data2 <- c(rmultinom(1, nsim_data, p2))
events_data3 <- c(rmultinom(1, nsim_data, p3))

events_mc1 <- c(rmultinom(1, nsim_mc, p1))
events_mc2 <- c(rmultinom(1, nsim_mc, p2))

x1_data1 <- rcauchy(events_data1[1], location = loctn[1], scale = scale[1])
x2_data1 <- rcauchy(events_data1[2], location = loctn[2], scale = scale[2])
x1_data2 <- rcauchy(events_data2[1], location = loctn[1], scale = scale[1])
x2_data2 <- rcauchy(events_data2[2], location = loctn[2], scale = scale[2])
x3_data2 <- rcauchy(events_data2[3], location = loctn[3], scale = scale[3])
x1_data3 <- rcauchy(events_data3[1], location = loctn[1], scale = scale[1])
x2_data3 <- rcauchy(events_data3[2], location = loctn[2], scale = scale[2])
x3_data3 <- rcauchy(events_data3[3], location = loctn[3], scale = scale[3])
x1_mc1 <- rcauchy(events_mc1[1], location = loctn[1], scale = scale[1])
x2_mc1 <- rcauchy(events_mc1[2], location = loctn[2], scale = scale[2])
x1_mc2 <- rcauchy(events_mc2[1], location = loctn[1], scale = scale[1])
x2_mc2 <- rcauchy(events_mc2[2], location = loctn[2], scale = scale[2])
x3_mc2 <- rcauchy(events_mc2[3], location = loctn[3], scale = scale[3])

x_data <- c(x1_data1,x2_data1,
            x1_data2,x2_data2,x3_data2,
            x1_data3,x2_data3,x3_data3)
x_mc <- c(x1_mc1,x2_mc1,
          x1_mc2,x2_mc2,x3_mc2)

# Efficiency
xdetected_data <- rbernoulli(nsim_data,1-exp(-sqrt(abs(x_data))/4)) == 1
xdetected_mc <- rbernoulli(nsim_mc,1-exp(-sqrt(abs(x_mc))/4)) == 1

# Add Smearing
err_mu_data <- -abs(x_data)^(1/4)
err_sd_data <- log((abs(x_data)+10)/4)
y_data <- x_data + rnorm(3*nsim_data, mean = err_mu_data, sd = err_sd_data)

err_mu_mc <- -abs(x_mc)^(1/4)
err_sd_mc <- log((abs(x_mc)+10)/4)
y_mc <- x_mc + rnorm(2*nsim_mc, mean = err_mu_mc, sd = err_sd_mc)

# Binned representation
xymin <- 2
xymax <- 27
xystep <- 3
dxy <- 2
xyaxes <- c(xymin-dxy,xymin,
            seq(xymin+xystep,xymax-xystep,xystep),
            xymax,xymax+dxy)

sims_data <- tibble("Theory" = 
                      rep(c("Theory 1","Theory 2","Theory 3"),
                          each = nsim_data),
                    "Truth" = x_data,
                    "Reconstructed" = y_data,
                    "Detected" = xdetected_data) %>%
  filter(Truth <= 30 & Truth >= 0)
sims_mc <- tibble("Theory" = 
                    rep(c("Theory 1","Theory 2"),
                        each = nsim_mc),
                  "Truth" = x_mc,
                  "Reconstructed" = y_mc,
                  "Detected" = xdetected_mc) %>%
  filter(Truth <= 30 & Truth >= 0)


bins_data <- sims_data %>%
  pivot_longer(c(Reconstructed,Truth), 
               names_to = "Treatment", 
               values_to = "Bin") %>%
  mutate(Bin = ceiling(Bin)) %>%
  filter(Bin <= 30 & Bin >= 1) %>%
  filter((Treatment == "Reconstructed" & Detected == TRUE) | Treatment == "Truth") %>%
  count(Theory, Bin, Treatment, name = "Counts") %>%
  complete(Theory, Bin=1:30, Treatment, fill = list(Counts=0)) %>%
  mutate(LBin = Bin-1,
         LCounts = cbind(
           rbind(diag(rep(1,62))[c(3,4,3:58,61,62),-c(1,2)],diag(0,60),diag(0,60)),
           rbind(diag(0,60),diag(rep(1,62))[c(3,4,3:58,61,62),-c(1,2)],diag(0,60)),
           rbind(diag(0,60),diag(0,60),diag(rep(1,62))[c(3,4,3:58,61,62),-c(1,2)])) %*% 
           Counts) %>%
  mutate(Density = Counts/nsim_data,
         LDensity = LCounts/nsim_data) %>%
  select(Theory, Treatment,LBin,Bin,LCounts,Counts,LDensity,Density)

bins_mc <- sims_mc %>%
  pivot_longer(c(Reconstructed,Truth), 
               names_to = "Treatment", 
               values_to = "Bin") %>%
  mutate(Bin = ceiling(Bin)) %>%
  filter(Bin <= 30 & Bin >= 1) %>%
  filter((Treatment == "Reconstructed" & Detected == TRUE) | Treatment == "Truth") %>%
  count(Theory, Bin, Treatment, name = "Counts") %>%
  complete(Theory, Bin=1:30,  Treatment, fill = list(Counts=0)) %>%
  mutate(LBin = Bin-1,
         LCounts = cbind(
           rbind(diag(rep(1,62))[c(3,4,3:58,61,62),-c(1,2)],diag(0,60)),
           rbind(diag(0,60),diag(rep(1,62))[c(3,4,3:60),-c(1,2)])) %*% 
           Counts) %>%
  mutate(Density = Counts/nsim_data,
         LDensity = LCounts/nsim_data) %>%
  select(Theory,Treatment,LBin,Bin,LCounts,Counts,LDensity,Density)

bins_all <- rbind(bins_data,bins_mc) %>%
  mutate(Source = c(rep("Data",180),rep("MC",120)),
         LCounts = LCounts/c(rep(1,180),rep(dmrat,120)),
         Counts = Counts/c(rep(1,180),rep(dmrat,120))) %>%
  mutate(Name = paste(Treatment,Source)) %>%
  filter(Source == "MC" | Treatment == "Reconstructed")

bins_all$Name[which(bins_all$Source == "Data")] <- "Reconstructed Data"

#max(sims_mc$Truth,sims_mc$Reconstructed,sims_data$Truth,sims_data$Reconstructed)
```

```{r, echo = F}
# Continuous representation
X <- seq(0,30,0.01)
nx <- length(X)

fp1x <- dcauchy(X, location = loctn[1], scale = scale[1]) 
fp2x <- dcauchy(X, location = loctn[2], scale = scale[2])
fp3x <- dcauchy(X, location = loctn[3], scale = scale[3])
#fx <- p*dlnorm(X, meanlog = 2.25, sdlog = 0.25) +
#  (1-p)*dlnorm(X, meanlog = 2.8, sdlog = 0.15)

fpx_truth1 <- tibble(X = rep(X,2), Density = c(p1[1]*fp1x,p1[2]*fp2x), 
                     Process = rep(c("Process 1","Process 2"), each = nx),
                     Theory = rep("Theory 1",2*nx))
fpx_truth2 <- tibble(X = rep(X,3), Density = c(p2[1]*fp1x,p2[2]*fp2x,p2[3]*fp3x), 
                     Process = rep(c("Process 1","Process 2","Process 3"), each = nx),
                     Theory = rep("Theory 2",3*nx))
fx_truth1 <- tibble(X = X, Density = p1[1]*fp1x + p1[2]*fp2x, 
                    Theory = rep("Theory 1",nx),Treatment = rep("Truth",nx))
fx_truth2 <- tibble(X = X, Density = p2[1]*fp1x + p2[2]*fp2x + p2[3]*fp3x,
                    Theory = rep("Theory 2",nx),Treatment = rep("Truth",nx))
fy_truth1 <- read.csv("f1yEstimate.csv") %>% 
  mutate(Theory = "Theory 1", Treatment = "Reconstructed")
fy_truth2 <- read.csv("f2yEstimate.csv") %>% 
  mutate(Theory = "Theory 2", Treatment = "Reconstructed")
names(fy_truth1)[1] <- names(fx_truth1)[1] <- 
  names(fy_truth2)[1] <- names(fx_truth2)[1] <- "XY"

# Binned expected counts
bins_expected1 <- read.csv("hist1Expected.csv") %>%
  mutate(LDensity = LCounts,
         Density = Counts,
         LCounts = LCounts*nsim_data,
         Counts = Counts*nsim_data)
bins_expected2 <- read.csv("hist2Expected.csv") %>%
  mutate(LDensity = LCounts,
         Density = Counts,
         LCounts = LCounts*nsim_data,
         Counts = Counts*nsim_data)

# Counts max
fmax_density <- 1.05*max(c(bins_data$Density,bins_mc$Density,
                           fx_truth1$Density,fx_truth2$Density,
                           fy_truth1$Density,fy_truth2$Density,
                           bins_expected1$Density,bins_expected2$Density))
fmax_count <- 1.05*max(c(bins_data$Counts,bins_mc$Counts/dmrat,
                         fx_truth1$Density*nsim_data,fx_truth2$Density*nsim_data,
                         fy_truth1$Density*nsim_data,fy_truth2$Density*nsim_data,
                         bins_expected1$Counts,bins_expected2$Counts))
```

```{r, fig.height=7, fig.width=7.5, fig.align='center', echo = F}
# Plotting
continuous1 <- ggplot() + 
  theme_bw() +
  geom_line(data = filter(rbind(fpx_truth1,fpx_truth2),
                            X >= xymin-dxy &
                            X <= xymax+dxy),
            mapping = aes(x = X, 
                          y = nsim_data*Density,
                      color = Process,
                   linetype = Theory)) +
  scale_color_manual(name = NA,
                     labels = c("Process 1",
                                "Process 2",
                                "Process 3"),
                     breaks = c("Process 1",
                                "Process 2",
                                "Process 3"),
                     values = c("Process 1" = "#5e81b5",#alpha("#009E73",0.6),
                                "Process 2" = "#e19c24",#alpha("#0072B2",0.6),
                                "Process 3" = "#8fb032")) +#alpha("#0072B2",1))) +
  scale_linetype_manual(name = NA,
                        labels = c("Theory 1",
                                   "Theory 2"),
                        breaks = c("Theory 1",
                                   "Theory 2"),
                        values = c("Theory 1" = "solid",
                                   "Theory 2" = "solid")) +
  scale_x_continuous("X (Truth)",
                     breaks = xyaxes, 
                     limits = c(xymin-dxy,xymax+dxy), 
                     expand = c(0,0)) +
  scale_y_continuous("Counts",
                     limits = c(0,fmax_count), expand = c(0,0),
                     breaks = seq(0,ceiling(fmax_count),100))+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        plot.margin = margin(0.15, 0.16, 0.12, 0.1, "cm"),
        legend.text = element_text(size = 7),
        legend.title = element_blank(),
        legend.position = c(.99, 0.99),
        legend.justification = c("right", "top"),
        legend.box.just = "left",
        legend.key.height = unit(10,"points"),
        legend.margin = margin(1,5,5,5,"pt"))

continuous2 <- ggplot() + 
  theme_bw() +
  geom_line(data = rbind(fx_truth1,fx_truth2,
                         fy_truth1,fy_truth2) %>%
              filter(Theory == "Theory 1"),
            mapping = aes(x = XY, 
                          y = nsim_data*Density,
                      color = Treatment),
            alpha = 0.7) +
  geom_line(data = rbind(fx_truth1,fx_truth2,
                         fy_truth1,fy_truth2) %>%
              filter(Theory == "Theory 2"),
            mapping = aes(x = XY, 
                          y = nsim_data*Density,
                   linetype = Treatment),
            color = rep(c("#8fb032","#eb6235"), each=nx),
            alpha = 0.7) +
  scale_color_manual(name = NA,
                     labels = c("Truth",
                                "Reconstructed"),
                     breaks = c("Truth",
                                "Reconstructed"),
                     values = c("Truth" = "#5e81b5",
                                "Reconstructed" = "#e19c24")) + 
  scale_linetype_manual(name = NA,
                        labels = c("Truth",
                                   "Reconstructed"),
                        breaks = c("Truth",
                                   "Reconstructed"),
                        values = c("Truth" = "solid",
                                   "Reconstructed" = "solid")) +
  guides(color = guide_legend(title = "Theory 1", order = 1, 
                              override.aes = list(shape = NA,
                                                  alpha = 0.7),
                              title.vjust = unit(-0.2, "pt")),
         linetype = guide_legend(title = "Theory 2", order = 2, 
                                 override.aes = list(color = c("#8fb032","#eb6235"),
                                                     alpha = c(0.8,0.8)),
                                 title.vjust = unit(-0.2, "pt"))) +
  scale_x_continuous("X (Truth), Y (Reconstructed)",
                     breaks = seq(0,30,3), 
                     limits = c(0,30), 
                     expand = c(0,0)) +
  scale_y_continuous("Counts",
                     limits = c(0,fmax_count), expand = c(0,0),
                     breaks = seq(0,ceiling(fmax_count),100)) +
  labs(title = "Scaled Exact Distributions") +
  theme(legend.text = element_text(size = 8),
        legend.title = element_text(size = 9),
        legend.justification = c("left", "top"),
        legend.box.just = "left",
        legend.spacing.y = unit(1, "pt"),
        legend.key.height = unit(10,"points"),
        legend.margin = margin(1,5,5,5,"pt"),
        aspect.ratio = 1,
        axis.title.y = element_blank())

# eb6235
# 8fb032

```

```{r, fig.height=7, fig.width=7.5, fig.align='center', echo = F, eval = F}
discrete_exp <- ggplot() + 
  theme_bw() +
  geom_segment(data = filter(bins_expected1, 
                             Treatment == "Truth" &
                                  LBin >= xymin-dxy &
                                   Bin <= xymax+dxy),
               mapping = aes(x = LBin,
                             y = Counts,
                          xend = Bin,
                          yend = Counts,
                         color = "E[Theory 1 Truth]",
                      linetype = "E[Theory 1 Truth]")) +
  geom_segment(data = filter(bins_expected1, 
                             Treatment == "Truth" &
                                  LBin >= xymin-dxy &
                                   Bin <= xymax+dxy),
               mapping = aes(x = LBin,
                             y = LCounts,
                          xend = LBin,
                          yend = Counts,
                         color = "E[Theory 1 Truth]",
                      linetype = "E[Theory 1 Truth]")) +
  geom_segment(data = filter(bins_expected1, 
                             Treatment == "Reconstructed" &
                                  LBin >= xymin-dxy &
                                   Bin <= xymax+dxy),
               mapping = aes(x = LBin,
                             y = Counts,
                          xend = Bin,
                          yend = Counts,
                         color = "E[Theory 1 Reconstructed]",
                      linetype = "E[Theory 1 Reconstructed]")) +
  geom_segment(data = filter(bins_expected1, 
                             Treatment == "Reconstructed" &
                                  LBin >= xymin-dxy &
                                   Bin <= xymax+dxy),
               mapping = aes(x = LBin,
                             y = LCounts,
                          xend = LBin,
                          yend = Counts,
                         color = "E[Theory 1 Reconstructed]",
                      linetype = "E[Theory 1 Reconstructed]")) +
  geom_segment(data = filter(bins_expected2, 
                             Treatment == "Truth" &
                                  LBin >= xymin-dxy &
                                   Bin <= xymax+dxy),
               mapping = aes(x = LBin,
                             y = Counts,
                          xend = Bin,
                          yend = Counts,
                         color = "E[Theory 2 Truth]",
                      linetype = "E[Theory 2 Truth]")) +
  geom_segment(data = filter(bins_expected2, 
                             Treatment == "Truth" &
                                  LBin >= xymin-dxy &
                                   Bin <= xymax+dxy),
               mapping = aes(x = LBin,
                             y = LCounts,
                          xend = LBin,
                          yend = Counts,
                         color = "E[Theory 2 Truth]",
                      linetype = "E[Theory 2 Truth]")) +
  geom_segment(data = filter(bins_expected2, 
                             Treatment == "Reconstructed" &
                                  LBin >= xymin-dxy &
                                   Bin <= xymax+dxy),
               mapping = aes(x = LBin,
                             y = Counts,
                          xend = Bin,
                          yend = Counts,
                         color = "E[Theory 2 Reconstructed]",
                      linetype = "E[Theory 2 Reconstructed]")) +
  geom_segment(data = filter(bins_expected2, 
                             Treatment == "Reconstructed" &
                                  LBin >= xymin-dxy &
                                   Bin <= xymax+dxy),
               mapping = aes(x = LBin,
                             y = LCounts,
                          xend = LBin,
                          yend = Counts,
                         color = "E[Theory 2 Reconstructed]",
                      linetype = "E[Theory 2 Reconstructed]")) +
  scale_x_continuous("X (Truth), Y (Reconstructed)",
                     breaks = xyaxes, 
                     limits = c(xymin-dxy,xymax+dxy), 
                     expand = c(0,0)) +
  scale_y_continuous("Counts",
                     limits = c(0,fmax_count), expand = c(0,0),
                     breaks = seq(0,ceiling(fmax_count),
                                  floor(fmax_count/1000)*200)) +
  scale_color_manual(name = NA,
                     labels = c("E[Theory 1 Truth]",
                                "E[Theory 2 Truth]",
                                "E[Theory 1 Reconstructed]",
                                "E[Theory 2 Reconstructed]"),
                     breaks = c("E[Theory 1 Truth]",
                                "E[Theory 2 Truth]",
                                "E[Theory 1 Reconstructed]",
                                "E[Theory 2 Reconstructed]"),
                     values = c("E[Theory 1 Truth]" = alpha("#5e81b5",1),#alpha("#009E73",0.6),
                                "E[Theory 2 Truth]" = alpha("#5e81b5",1),#alpha("#009E73",1),
                                "E[Theory 1 Reconstructed]" = alpha("#e19c24",1),#alpha("#0072B2",0.6),
                                "E[Theory 2 Reconstructed]" = alpha("#e19c24",1))) +#alpha("#0072B2",1))) +
  scale_linetype_manual(name = NA,
                        labels = c("E[Theory 1 Truth]",
                                   "E[Theory 2 Truth]",
                                   "E[Theory 1 Reconstructed]",
                                   "E[Theory 2 Reconstructed]"),
                        breaks = c("E[Theory 1 Truth]",
                                   "E[Theory 2 Truth]",
                                   "E[Theory 1 Reconstructed]",
                                   "E[Theory 2 Reconstructed]"),
                        values = c("E[Theory 1 Truth]" = "solid",
                                   "E[Theory 2 Truth]" = "dashed",
                                   "E[Theory 1 Reconstructed]" = "solid",
                                   "E[Theory 2 Reconstructed]" = "dashed")) +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        plot.margin = margin(0.15, 0.16, 0.12, 0.1, "cm"),
        legend.text = element_text(size = 7),
        legend.title = element_blank(),
        legend.position = c(.01, 0.99),
        legend.justification = c("left", "top"),
        legend.box.just = "left",
        legend.key.height = unit(10,"points"),
        legend.margin = margin(1,5,5,5,"pt"),
        axis.title.x = element_blank()) +
  guides(color = guide_legend(override.aes = list(alpha = c(1,1,1,1))))

discrete_theory1 <- ggplot() + 
  theme_bw() +
  geom_segment(data = filter(bins_all,
                               Theory == "Theory 1" &
                               LBin >= xymin-dxy &
                               Bin <= xymax+dxy),
               mapping = aes(x = LBin,
                             y = Counts,
                          xend = Bin,
                          yend = Counts,
                         color = Name)) +
  geom_segment(data = filter(bins_all, 
                               Theory == "Theory 1" &
                               LBin >= xymin-dxy &
                               Bin <= xymax+dxy),
               mapping = aes(x = LBin,
                             y = LCounts,
                          xend = LBin,
                          yend = Counts,
                         color = Name)) +
  scale_x_continuous("X (Truth), Y (Reconstructed)",
                     breaks = xyaxes, 
                     limits = c(xymin-dxy,xymax+dxy), 
                     expand = c(0,0)) +
  scale_y_continuous("Counts",
                     limits = c(0,fmax_count), expand = c(0,0),
                     breaks = seq(0,ceiling(fmax_count),
                                  floor(fmax_count/1000)*200)) +
  scale_color_manual(name = "Theory 1",
                     labels = c("MC Truth",
                                "Data Truth",
                                "MC Reconstructed",
                                "Data Reconstructed"),
                     breaks = c("MC Truth",
                                "Data Truth",
                                "MC Reconstructed",
                                "Data Reconstructed"),
                     values = c("MC Truth" = alpha("#5e81b5",1),#alpha("#009E73",0.6),
                                "Data Truth" = alpha("#e19c24",1),#alpha("#009E73",1),
                                "MC Reconstructed" = alpha("#8fb032",1),#alpha("#0072B2",0.6),
                                "Data Reconstructed" = alpha("#eb6235",1))) +#alpha("#0072B2",1))) +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        plot.margin = margin(0.15, 0.16, 0.12, 0.1, "cm"),
        legend.text = element_text(size = 8),
        legend.title = element_blank(),
        legend.position = c(.01, 0.99),
        legend.justification = c("left", "top"),
        legend.box.just = "left",
        legend.key.height = unit(10,"points"),
        legend.margin = margin(1,5,5,5,"pt"),
        axis.title.x = element_blank()) +
  guides(color = guide_legend(override.aes = list(alpha = c(1,1,1,1))))

discrete_theory2 <- ggplot() + 
  theme_bw() +
  geom_segment(data = filter(bins_all,
                               Theory == "Theory 2" &
                               LBin >= xymin-dxy &
                               Bin <= xymax+dxy),
               mapping = aes(x = LBin,
                             y = Counts,
                          xend = Bin,
                          yend = Counts,
                         color = Name)) +
  geom_segment(data = filter(bins_all, 
                               Theory == "Theory 2" &
                               LBin >= xymin-dxy &
                               Bin <= xymax+dxy),
               mapping = aes(x = LBin,
                             y = LCounts,
                          xend = LBin,
                          yend = Counts,
                         color = Name)) +
  scale_x_continuous("X (Truth), Y (Reconstructed)",
                     breaks = xyaxes, 
                     limits = c(xymin-dxy,xymax+dxy), 
                     expand = c(0,0)) +
  scale_y_continuous("Counts",
                     limits = c(0,fmax_count), expand = c(0,0),
                     breaks = seq(0,ceiling(fmax_count),
                                  floor(fmax_count/1000)*200)) +
  scale_color_manual(name = "Theory 2",
                     labels = c("MC Truth",
                                "Data Truth",
                                "MC Reconstructed",
                                "Data Reconstructed"),
                     breaks = c("MC Truth",
                                "Data Truth",
                                "MC Reconstructed",
                                "Data Reconstructed"),
                     values = c("MC Truth" = alpha("#5e81b5",1),#alpha("#009E73",0.6),
                                "Data Truth" = alpha("#e19c24",1),#alpha("#009E73",1),
                                "MC Reconstructed" = alpha("#8fb032",1),#alpha("#0072B2",0.6),
                                "Data Reconstructed" = alpha("#eb6235",1))) +#alpha("#0072B2",1))) +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        plot.margin = margin(0.15, 0.16, 0.12, 0.1, "cm"),
        legend.text = element_text(size = 8),
        legend.title = element_blank(),
        legend.position = c(.01, 0.99),
        legend.justification = c("left", "top"),
        legend.box.just = "left",
        legend.key.height = unit(10,"points"),
        legend.margin = margin(1,5,5,5,"pt"),
        axis.title.x = element_blank()) +
  guides(color = guide_legend(override.aes = list(alpha = c(1,1,1,1))))
```

```{r, fig.height=4, fig.width=7.5, fig.align='center', echo = F}
################### MC and Data #################################

discrete_DataMC <- ggplot() + 
  theme_bw() +
  geom_segment(data = filter(bins_all,
                               LBin >= 0 &
                               Bin <= 30 &
                               Source == "MC" &
                               Theory == "Theory 1"),
               mapping = aes(x = LBin,
                             y = Counts,
                          xend = Bin,
                          yend = Counts,
                         color = Name),
               alpha = 0.7) +
  geom_segment(data = filter(bins_all,
                               LBin >= 0 &
                               Bin <= 30 &
                               Source == "MC" &
                               Theory == "Theory 1"),
               mapping = aes(x = LBin,
                             y = LCounts,
                          xend = LBin,
                          yend = Counts,
                         color = Name),
               alpha = 0.7) +
  geom_segment(data = bins_all %>% 
                 filter(LBin >= 0 &
                          Bin <= 30 &
                          Source == "MC" &
                          Theory == "Theory 2") %>%
                 arrange(desc(Treatment)),
               mapping = aes(x = LBin,
                             y = Counts,
                          xend = Bin,
                          yend = Counts,
                      linetype = Name),
                         color = rep(c("#eb6235","#8fb032"),each=30),
               alpha = 0.7) +
  geom_segment(data = bins_all %>% 
                 filter(LBin >= 0 &
                          Bin <= 30 &
                          Source == "MC" &
                          Theory == "Theory 2") %>% 
                 arrange(desc(Treatment)),
               mapping = aes(x = LBin,
                             y = LCounts,
                          xend = LBin,
                          yend = Counts,
                      linetype = Name),
                         color = rep(c("#eb6235","#8fb032"),each=30),
               alpha = 0.7) +
  geom_point(data = bins_all %>% 
               filter(LBin >= 0 & Bin <= 30 &
                        Source == "Data" & Theory == "Theory 2"),
             mapping = aes(x = LBin+0.5,
                           y = Counts,
                           fill = "Reconstructed"),
             shape = 20, color = "black") +
  scale_x_continuous("X (Truth), Y (Reconstructed)",
                     breaks = seq(0,30,3), 
                     limits = c(0,30), 
                     expand = c(0,0)) +
  scale_y_continuous("Counts",
                     limits = c(0,fmax_count), expand = c(0,0),
                     breaks = seq(0,ceiling(fmax_count),100)) +
  scale_color_manual(name = NA,
                     labels = c("Truth",
                                "Reconstructed"),
                     breaks = c("Truth MC",
                                "Reconstructed MC"),
                     values = c("Truth MC" = "#5e81b5",
                                "Reconstructed MC" = "#e19c24")) + #"#eb6235","#8fb032"
  scale_linetype_manual(name = NA,
                        labels = c("Truth",
                                   "Reconstructed"),
                        breaks = c("Truth MC",
                                   "Reconstructed MC"),
                        values = c("Truth MC" = "solid",
                                   "Reconstructed MC" = "solid")) +
  guides(color = guide_legend(title = "Theory 1", order = 1, 
                              override.aes = list(shape = NA,
                                                  alpha = 0.7),
                              title.vjust = unit(-0.5, "pt")),
         linetype = guide_legend(title = "Theory 2", order = 2, 
                                 override.aes = list(color = c("#eb6235","#8fb032"),
                                                     alpha = 0.7),
                                 title.vjust = unit(-0.5, "pt")),
         fill = guide_legend(title = "Data", order = 3, title.vjust = unit(-0.5, "pt"))) +
  labs(title = "MC Simulations and ''Data''") +
  theme(legend.title = element_text(size = 9),
        legend.text = element_text(size = 8),
        legend.box.just = "left",
        legend.spacing.y = unit(-2.5, "pt"),
        legend.key.height = unit(10,"points"),
        aspect.ratio = 1,
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.y = element_blank())
```

```{r, fig.align='center', echo = F, fig.height=3.5}
########## MIGRATION ###########################################################

migration <- sims_mc %>%
  filter(Detected == TRUE &
           Truth <= 30 & Truth >= 0) %>%
  ggplot() +
    scale_y_continuous(breaks = seq(0,30,by=3),
                       limits = c(0,30), 
                       expand = c(0,0)) +
    scale_x_continuous(breaks = seq(-3,36,by=3), 
                       limits = c(-5,37), 
                       expand = c(0,0)) +
    theme_bw() +
    stat_bin2d(geom="raster",
               mapping = aes(x = Reconstructed, 
                             y = Truth), 
               breaks = list(x = seq(-4,36,1),
                             y = seq(0,30,1))) +
    labs(x = "Y (Reconstructed)", y = "X (Truth)",
         title = "MC Event Migration") +
    geom_abline(intercept=0,slope=1,lty="dashed",col="red") +
    facet_grid(~Theory) + coord_equal(ratio = 1)

gradient_max <- max(ggplot_build(migration)$data[[1]]$count)
gmins <- abs(floor(gradient_max/10^(floor(log10(gradient_max))-1))/
               c(5,10,20,25,50)-1)
gradient_step <- c(5,10,20,25,50)[which(gmins == min(gmins))]*
  10^(floor(log10(gradient_max))-2)

migration <- migration +
  scale_fill_gradientn(colours = viridis(11),
                       breaks = seq(0,gradient_max,gradient_step),
                       guide = guide_colourbar(barwidth = 1, 
                                               barheight = 8.5,
                                               frame.colour = "black",
                                               ticks.colour = "black",
                                               title = "Counts"))
migration
```
\begin{figure}[!ht]
    \centering
    \hrulefill
```{r, fig.height=3, fig.width=7.5, fig.align='center', echo = F}
plot1 <- ggplotGrob(continuous2 + theme(legend.position = "none",
                                        axis.title.x = element_blank()))
plot2 <- ggplotGrob(discrete_DataMC + theme(legend.position = "none",
                                        axis.title.x = element_blank()))
#list(plot1$widths,plot2$widths)

#plot1$widths[3] <- plot2$widths[9]
#plot1$widths[6] <- plot2$widths[6]

egg::ggarrange(continuous2 + theme(legend.position = "none", axis.title.x = element_blank()), 
               discrete_DataMC + theme(axis.title.x = element_blank()), nrow = 1,
               left = textGrob("Counts", rot = 90, vjust = 0.25),
               bottom = textGrob("X (Truth), Y (Reconstructed)", hjust = 0.8))
```
  \caption{\emph{The above plots feature two bimodal gamma distributions depicting events before and after after detector effects. (Top Left) The two continuous distributions correspond to the theoretical PDFs of the two distributions rescaled to correspond with the counts from 20,000 events. The histograms are calculated from the PDFs and correspond to the expected event counts from 20,000 simulated events. (Bottom Left) These four histograms consist of the same expected event counts as well as one instance of actual counts resulting from 20,000 simulated events. (Right) A visual study of simulated detector efficiency is provided by a side-by-side comparison of two heat maps that demonstrate the skewness and dispersion added by a simulated measurement process for detected and undetected events. This study is not intended to meaningfully represent a hypothetical distribution of undetected events in any real detector. Actual detector efficiencies are almost certainly governed by much more complicated collections of parameters.}}
  \label{BasicExample}
  \hrulefill
\end{figure}

```{r, echo=F}
### Data 1
dataReco1 <- sims_data %>%
  filter(Theory == "Theory 1" &
           Truth <= 30 & Truth >= 0 &
           Detected == TRUE) %>%
  mutate(Bin = ceiling(Reconstructed)) %>%
  count(Bin, name = "Counts") %>%
  select(Bin, Counts)
sidedata1 <- dataReco1 %>%
  filter(Bin < 1 | Bin > 30) %>% pull(Bin)
dataReco1 <- dataReco1 %>%
  filter(Bin >= 1 & Bin <= 30) %>%
  rbind(dataReco1 %>% filter(Bin < 1 | Bin > 30) %>%
          mutate(Counts = sum(Counts)) %>% 
          filter(Bin == 31))

dataTruth1 <- sims_data %>%
  filter(Theory == "Theory 1" &
           Truth <= 30 & Truth >= 0) %>%
  mutate(Bin = ceiling(Truth)) %>%
  count(Bin, name = "Counts") %>%
  select(Bin, Counts)

### Data 2
dataReco2 <- sims_data %>%
  filter(Theory == "Theory 2" &
           Truth <= 30 & Truth >= 0 &
           Detected == TRUE) %>%
  mutate(Bin = ceiling(Reconstructed)) %>%
  count(Bin, name = "Counts") %>%
  select(Bin, Counts)
sidedata2 <- dataReco2 %>%
  filter(Bin < 1 | Bin > 30) %>% pull(Bin)
dataReco2 <- dataReco2 %>%
  filter(Bin >= 1 & Bin <= 30) %>%
  rbind(dataReco2 %>% filter(Bin < 1 | Bin > 30) %>%
          mutate(Counts = sum(Counts)) %>% 
          filter(Bin == 31))

dataTruth2 <- sims_data %>%
  filter(Theory == "Theory 2" &
           Truth <= 30 & Truth >= 0) %>%
  mutate(Bin = ceiling(Truth)) %>%
  count(Bin, name = "Counts") %>%
  select(Bin, Counts)

### Data 3
dataReco3 <- sims_data %>%
  filter(Theory == "Theory 3" &
           Truth <= 30 & Truth >= 0 &
           Detected == TRUE) %>%
  mutate(Bin = ceiling(Reconstructed)) %>%
  count(Bin, name = "Counts") %>%
  select(Bin, Counts)
sidedata3 <- dataReco3 %>%
  filter(Bin < 1 | Bin > 30) %>% pull(Bin)
dataReco3 <- dataReco3 %>%
  filter(Bin >= 1 & Bin <= 30) %>%
  rbind(dataReco2 %>% filter(Bin < 1 | Bin > 30) %>%
          mutate(Counts = sum(Counts)) %>% 
          filter(Bin == 31))

dataTruth3 <- sims_data %>%
  filter(Theory == "Theory 3" &
           Truth <= 30 & Truth >= 0) %>%
  mutate(Bin = ceiling(Truth)) %>%
  count(Bin, name = "Counts") %>%
  select(Bin, Counts)

### MC 1
mcReco1 <- sims_mc %>%
  filter(Theory == "Theory 1" &
           Truth <= 30 & Truth >= 0 &
           Detected == TRUE) %>%
  mutate(Bin = ceiling(Reconstructed)) %>%
  count(Bin, name = "Counts") %>%
  select(Bin, Counts)

sidemc1 <- mcReco1 %>%
  filter(Bin < 1 | Bin > 30) %>% pull(Bin)
mcmat1 <- matrix(rep(0,31*max(sidemc1-min(sidemc1)+1)),ncol=31)
mcmat1[(1:30-min(sidemc1)+1),1:30] <- diag(1,30)
mcmat1[(sidemc1-min(sidemc1)+1),31] <- 1

mcReco1 <- mcReco1 %>%
  filter(Bin >= 1 & Bin <= 30) %>%
  rbind(mcReco1 %>% filter(Bin < 1 | Bin > 30) %>%
          mutate(Counts = sum(Counts)) %>% 
          filter(Bin == 31))

mcTruth1 <- sims_mc %>%
  filter(Theory == "Theory 1" &
           Truth <= 30 & Truth >= 0) %>%
  mutate(Bin = ceiling(Truth)) %>%
  count(Bin, name = "Counts") %>%
  select(Bin, Counts)

### MC 2
mcReco2 <- sims_mc %>%
  filter(Theory == "Theory 2" &
           Truth <= 30 & Truth >= 0 &
           Detected == TRUE) %>%
  mutate(Bin = ceiling(Reconstructed)) %>%
  count(Bin, name = "Counts") %>%
  select(Bin, Counts)

sidemc2 <- mcReco2 %>%
  filter(Bin < 1 | Bin > 30) %>% pull(Bin)
mcmat2 <- matrix(rep(0,31*max(sidemc2-min(sidemc2)+1)),ncol=31)
mcmat2[(1:30-min(sidemc2)+1),1:30] <- diag(1,30)
mcmat2[(sidemc2-min(sidemc2)+1),31] <- 1

mcReco2 <- mcReco2 %>%
  filter(Bin >= 1 & Bin <= 30) %>%
  rbind(mcReco2 %>% filter(Bin < 1 | Bin > 30) %>%
          mutate(Counts = sum(Counts)) %>% 
          filter(Bin == 31))

mcTruth2 <- sims_mc %>%
  filter(Theory == "Theory 2" &
           Truth <= 30 & Truth >= 0) %>%
  mutate(Bin = ceiling(Truth)) %>%
  count(Bin, name = "Counts") %>%
  select(Bin, Counts)


```

\section{Unfolding in particle physics}

\subsection{Bin-by-bin}

In this approach a multiplicative \textbf{correction factor} $C_i$ is applied to the observed number of signal events $n_i$ for each bin to produce the estimator of $\mu_i$ \cite{Cowan1998},
\begin{align}
  \hat{\mu}_i &= C_in_i.\label{eq:binest}
\end{align}
The correction factors are determined by taking the respective ratios of a bin's MC simulated truth signal event counts $\mu_i^{\text{MC}}$ to its MC simulated reconstructed signal event counts $\nu_i^{\text{MC}}$,
\begin{align}C_i = \frac{\mu_i^{\text{MC}}}{\nu_i^{\text{MC}}}.\label{eq:cfact}\end{align}
The covariance matrix $\bm{U}$ of this estimator derives naturally from Equations \eqref{eq:cov} and \eqref{eq:binest}, with components
\begin{align}
  U_{ij}&=\text{Cov}[\hat\mu_i,\hat\mu_j]\nonumber\\
  &=C_iC_j\text{Cov}[n_i,n_j]\nonumber\\
  &=C_i^2\delta_{ij}\nu_i.\label{eq:bincov}
\end{align}
The expectation value of the estimate can be calculated easily enough as well, and with it the bias 
\begin{align}
  \text{Bias}[\hat{\mu}_i]&=E_i[\hat{\mu}_i]-\mu_i\nonumber\\ 
  &= C_iE[n_i]-\mu_i\nonumber\\ 
  &= \frac{\mu_i^{\text{MC}}}{\nu_i^{\text{MC}}}\nu_i-\mu_i\nonumber\\
  &= \left(\frac{\mu_i^{\text{MC}}}{\nu_i^{\text{MC}}}-\frac{\mu_i}{\nu_i}\right)\nu_i.\label{eq:binbias}
\end{align}

```{r, echo = F}
BbB_bins <- tibble(Theory = c(rep(c("Theory 1","Theory 2","Theory 3"),each=60),
                              rep(c("Theory 1","Theory 2"),each=30)),
                   `Assumed Theory` = rep(rep(c("Theory 1","Theory 2"),each=30),4),
                   LBin = rep(0:29,8), Bin = rep(1:30,8),
                   LCounts = c(((mcTruth1$Counts/mcReco1$Counts[1:30])*
                                  dataReco1$Counts[1:30])[c(1,1:29)],
                               ((mcTruth2$Counts/mcReco2$Counts[1:30])*
                                  dataReco1$Counts[1:30])[c(1,1:29)],
                               ((mcTruth1$Counts/mcReco1$Counts[1:30])*
                                  dataReco2$Counts[1:30])[c(1,1:29)],
                               ((mcTruth2$Counts/mcReco2$Counts[1:30])*
                                  dataReco2$Counts[1:30])[c(1,1:29)],
                               ((mcTruth1$Counts/mcReco1$Counts[1:30])*
                                  dataReco3$Counts[1:30])[c(1,1:29)],
                               ((mcTruth2$Counts/mcReco2$Counts[1:30])*
                                  dataReco3$Counts[1:30])[c(1,1:29)],
                               mcTruth1$Counts[c(1,1:29)]/dmrat,
                               mcTruth2$Counts[c(1,1:29)]/dmrat),
                   Counts = c((mcTruth1$Counts/mcReco1$Counts[1:30])*
                                dataReco1$Counts[1:30],
                              (mcTruth2$Counts/mcReco2$Counts[1:30])*
                                dataReco1$Counts[1:30],
                              (mcTruth1$Counts/mcReco1$Counts[1:30])*
                                dataReco2$Counts[1:30],
                              (mcTruth2$Counts/mcReco2$Counts[1:30])*
                                dataReco2$Counts[1:30],
                              (mcTruth1$Counts/mcReco1$Counts[1:30])*
                                dataReco3$Counts[1:30],
                              (mcTruth2$Counts/mcReco2$Counts[1:30])*
                                dataReco3$Counts[1:30],
                              mcTruth1$Counts/dmrat,
                              mcTruth2$Counts/dmrat),
                   Name = c(rep(c("Theory 1 Data","Theory 2 Data",
                                  "Theory 3 Data"),each=60),
                            rep("MC",60)))

BbB_bins_res <- BbB_bins
BbB_bins_res <- BbB_bins_res %>% 
  mutate(`Assumed Theory` = rep(rep(c("Theory 1 Residuals",
                                      "Theory 2 Residuals"),each=30),4),
         LCounts = rep(c(0,mcTruth1$Counts[1:29]/dmrat,
                         0,mcTruth2$Counts[1:29]/dmrat),4) - LCounts,
         Counts = rep(c(mcTruth1$Counts/dmrat,
                        mcTruth2$Counts/dmrat),4) - Counts)
BbB_bins <- rbind(BbB_bins,BbB_bins_res)


ggplot() + 
  theme_bw() +
  geom_rect(data = BbB_bins %>%
              mutate(ymin = Counts - 
                       rep(sqrt(c((mcTruth1$Counts^2/
                                 mcReco1$Counts[1:30]),
                              (mcTruth2$Counts^2/
                                 mcReco2$Counts[1:30]))),8),
                     ymax = Counts + 
                       rep(sqrt(c((mcTruth1$Counts^2/
                                 mcReco1$Counts[1:30]),
                              (mcTruth2$Counts^2/
                                 mcReco2$Counts[1:30]))),8),
                     xmin = LBin, xmax = Bin),
            mapping = aes(xmin=xmin,ymin=ymin,
                          xmax=xmax,ymax=ymax,
                          fill=Name),alpha=0.2) +
  geom_segment(data = BbB_bins,
               mapping = aes(x = LBin,
                             y = Counts,
                          xend = Bin,
                          yend = Counts,
                         color = Name),
               alpha = 0.7) +
  geom_segment(data = BbB_bins,
               mapping = aes(x = LBin,
                             y = LCounts,
                          xend = LBin,
                          yend = Counts,
                         color = Name),
               alpha = 0.7) +
  scale_x_continuous("X (Truth)",
                     breaks = seq(0,30,by=3), 
                       limits = c(0,30), 
                       expand = c(0,0)) +
  scale_color_manual(labels = c("Theory 1 Data","Theory 2 Data","Theory 3 Data","MC"),
                     breaks = c("Theory 1 Data","Theory 2 Data","Theory 3 Data","MC"),
                     values = c("#5e81b5","#e19c24","#eb6235","#000000")) +
  scale_fill_manual(labels = c("Theory 1 Data","Theory 2 Data","Theory 3 Data","MC"),
                     breaks = c("Theory 1 Data","Theory 2 Data","Theory 3 Data","MC"),
                     values = c(alpha("#5e81b5",0.2),alpha("#e19c24",0.2),
                                alpha("#eb6235",0.2),NA)) +
  guides(fill = guide_legend("Key", override.aes = list(fill=c(alpha("#5e81b5",0.2),alpha("#e19c24",0.2),
                                alpha("#eb6235",0.2),NA))),
         color = guide_legend("Key")) +
  facet_wrap(`Assumed Theory` ~ ., ncol = 2, dir = "v", scales = "free")
```

```{r, echo = F}

biases <- c((mcTruth1$Counts/mcReco1$Counts[1:30] - 
  (bins_expected1 %>% filter(Treatment == "Truth") %>% pull(Counts))/
  (bins_expected1 %>% filter(Treatment == "Measured") %>% pull(Counts))) *
  (bins_expected1 %>% filter(Treatment == "Measured") %>% pull(Counts)),
  (mcTruth2$Counts/mcReco2$Counts[1:30] - 
  (bins_expected1 %>% filter(Treatment == "Truth") %>% pull(Counts))/
  (bins_expected1 %>% filter(Treatment == "Measured") %>% pull(Counts))) *
  (bins_expected1 %>% filter(Treatment == "Measured") %>% pull(Counts)),
  (mcTruth1$Counts/mcReco1$Counts[1:30] - 
  (bins_expected2 %>% filter(Treatment == "Truth") %>% pull(Counts))/
  (bins_expected2 %>% filter(Treatment == "Measured") %>% pull(Counts))) *
  (bins_expected2 %>% filter(Treatment == "Measured") %>% pull(Counts)),
  (mcTruth2$Counts/mcReco2$Counts[1:30] - 
  (bins_expected2 %>% filter(Treatment == "Truth") %>% pull(Counts))/
  (bins_expected2 %>% filter(Treatment == "Measured") %>% pull(Counts))) *
  (bins_expected2 %>% filter(Treatment == "Measured") %>% pull(Counts)),
  ((bins_expected1 %>% filter(Treatment == "Truth") %>% pull(Counts))/
  (bins_expected1 %>% filter(Treatment == "Measured") %>% pull(Counts))-
    (bins_expected2 %>% filter(Treatment == "Truth") %>% pull(Counts))/
  (bins_expected2 %>% filter(Treatment == "Measured") %>% pull(Counts))) *
    (bins_expected2 %>% filter(Treatment == "Measured") %>% pull(Counts)))

biasplotT1 <- plot(c(-1,31), c(0,0), lty=2, ylim=c(min(biases),max(biases)), type="l")
lines(1:30, biases[1:30], col="#5e81b5")
lines(1:30, biases[31:60], col="#8fb032")

biasplotT2 <- plot(c(-1,31), c(0,0), lty=2, ylim=c(min(biases),max(biases)), type="l")
lines(1:30, biases[61:90], col=4)
lines(1:30, biases[91:120], col=6)
```

\subsection{Inverting the Response Matrix}

```{r, echo=F}
R_mc1 <- sims_mc %>%
  filter(Theory == "Theory 1" &
           Detected == TRUE &
           Truth <= 30 & Truth >= 0) %>%
  mutate(Truth = ceiling(Truth),
         Reconstructed = ceiling(Reconstructed)) %>%
  count(Truth, Reconstructed, name = "Counts") %>%
  complete(Reconstructed=max(Reconstructed):min(Reconstructed),
           Truth=1:30, fill = list(Counts=0)) %>%
  pull(Counts) %>% matrix(byrow = T, ncol = 30) %>% 
  t() %*% mcmat1 %>% t() * matrix(rep(1/mcTruth1$Counts,each=31),ncol=30)

R_mc2 <- sims_mc %>%
  filter(Theory == "Theory 2" &
           Detected == TRUE &
           Truth <= 30 & Truth >= 0) %>%
  mutate(Truth = ceiling(Truth),
         Reconstructed = ceiling(Reconstructed)) %>%
  count(Truth, Reconstructed, name = "Counts") %>%
  complete(Reconstructed=max(Reconstructed):min(Reconstructed),
           Truth=1:30, fill = list(Counts=0)) %>%
  pull(Counts) %>% matrix(byrow = T, ncol = 30) %>% 
  t() %*% mcmat2 %>% t() * matrix(rep(1/mcTruth2$Counts,each=31),ncol=30)


Vnu1 <- diag(mcReco1$Counts/dmrat)
Vnu2 <- diag(mcReco2$Counts/dmrat)

inv_R_mc1 <- solve(t(R_mc1) %*% solve(Vnu1) %*% R_mc1) %*% t(R_mc1) %*% solve(Vnu1)
inv_R_mc2 <- solve(t(R_mc2) %*% solve(Vnu2) %*% R_mc2) %*% t(R_mc2) %*% solve(Vnu2)

Vmu1 <- inv_R_mc1 %*% Vnu1 %*% t(inv_R_mc1)
Vmu2 <- inv_R_mc2 %*% Vnu2 %*% t(inv_R_mc2)

data1_unfolded_mc1 <- inv_R_mc1 %*% dataReco1$Counts
data1_unfolded_mc2 <- inv_R_mc2 %*% dataReco1$Counts
data2_unfolded_mc1 <- inv_R_mc1 %*% dataReco2$Counts
data2_unfolded_mc2 <- inv_R_mc2 %*% dataReco2$Counts
data3_unfolded_mc1 <- inv_R_mc1 %*% dataReco3$Counts
data3_unfolded_mc2 <- inv_R_mc2 %*% dataReco3$Counts
mc1_unfolded_mc1 <- inv_R_mc1 %*% mcReco1$Counts
mc1_unfolded_mc2 <- inv_R_mc2 %*% mcReco1$Counts
mc2_unfolded_mc1 <- inv_R_mc1 %*% mcReco2$Counts
mc2_unfolded_mc2 <- inv_R_mc2 %*% mcReco2$Counts
```

```{r, echo=F}
bins_hat <- tibble(Theory = c(rep(c(rep(c("Theory 1","Theory 2","Theory 3"),each=30),
                                    rep(c("Theory 1","Theory 2"),each=30)),2),
                              c(rep(c("Theory 1","Theory 2","Theory 3"),each=60),
                                  rep(c("Theory 1","Theory 2"),each=60))),
                   `Assumed Theory` = c(rep(c(rep(c("Theory 1","Theory 2","Theory 3"),each=30),
                                    rep(c("Theory 1","Theory 2"),each=30)),2),
                              c(rep(rep(c("Theory 1","Theory 2"),each=30),5))),
                   LBin = rep(0:29,20),
                   Bin = rep(1:30,20),
                   LCounts = c(dataReco1$Counts[c(1,1:29)],
                               dataReco2$Counts[c(1,1:29)],
                               dataReco3$Counts[c(1,1:29)],
                               mcReco1$Counts[c(1,1:29)]/dmrat,
                               mcReco2$Counts[c(1,1:29)]/dmrat,
                               dataTruth1$Counts[c(1,1:29)],
                               dataTruth2$Counts[c(1,1:29)],
                               dataTruth3$Counts[c(1,1:29)],
                               mcTruth1$Counts[c(1,1:29)]/dmrat,
                               mcTruth2$Counts[c(1,1:29)]/dmrat,
                               data1_unfolded_mc1[c(1,1:29)],
                               data1_unfolded_mc2[c(1,1:29)],
                               data2_unfolded_mc1[c(1,1:29)],
                               data2_unfolded_mc2[c(1,1:29)],
                               data3_unfolded_mc1[c(1,1:29)],
                               data3_unfolded_mc2[c(1,1:29)],
                               mc1_unfolded_mc1[c(1,1:29)]/dmrat,
                               mc1_unfolded_mc2[c(1,1:29)]/dmrat,
                               mc2_unfolded_mc1[c(1,1:29)]/dmrat,
                               mc2_unfolded_mc2[c(1,1:29)]/dmrat),
                   Counts = c(dataReco1$Counts[1:30],
                              dataReco2$Counts[1:30],
                              dataReco3$Counts[1:30],
                              mcReco1$Counts[1:30]/dmrat,
                              mcReco2$Counts[1:30]/dmrat,
                              dataTruth1$Counts,
                              dataTruth2$Counts,
                              dataTruth3$Counts,
                              mcTruth1$Counts/dmrat,
                              mcTruth2$Counts/dmrat,
                              data1_unfolded_mc1,
                              data1_unfolded_mc2,
                              data2_unfolded_mc1,
                              data2_unfolded_mc2,
                              data3_unfolded_mc1,
                              data3_unfolded_mc2,
                              mc1_unfolded_mc1/dmrat,
                              mc1_unfolded_mc2/dmrat,
                              mc2_unfolded_mc1/dmrat,
                              mc2_unfolded_mc2/dmrat),
                   Treatment = c(rep(c("Reconstructed","Truth"),each=5*30),
                                 rep("TruthHat",300)),
                   Source = c(rep("Data",3*30),rep("MC",2*30),
                              rep("Data",3*30),rep("MC",2*30),
                              rep("Data",6*30),rep("MC",4*30)),
                   Name = c(rep("Reconstucted Theory 1 Data",30),
                            rep("Reconstucted Theory 2 Data",30),
                            rep("Reconstucted Theory 3  Data",30),
                            rep("Reconstucted Theory 1  MC",30),
                            rep("Reconstucted Theory 2  MC",30),
                            rep("Truth Theory 1 Data",30),
                            rep("Truth Theory 2 Data",30),
                            rep("Truth Theory 3 Data",30),
                            rep("Truth Theory 1 MC",30),
                            rep("Truth Theory 2 MC",30),
                            rep("Unfolded Theory 1 Data",60),
                            rep("Unfolded Theory 2 Data",60),
                            rep("Unfolded Theory 3 Data",60),
                            rep("Unfolded Theory 1 MC",60),
                            rep("Unfolded Theory 2 MC",60)),
                   Error = c(sqrt(diag(Vnu1))[1:30],
                             sqrt(diag(Vnu2))[1:30],
                             rep(0,30),
                             sqrt(diag(Vmu1)),
                             sqrt(diag(Vmu2)),
                             rep(0,11*30),
                             sqrt(diag(Vmu1)),
                             sqrt(diag(Vmu2)),
                             sqrt(diag(Vmu1)),
                             sqrt(diag(Vmu2))))

bins_hat <- bins_hat %>%
  mutate(Step = "Counts") %>%
  rbind(bins_hat %>% 
          filter(Treatment == "TruthHat") %>%
          mutate(LCounts = rep(bins_hat %>% 
                                 filter(Source == "MC" & Treatment == "Truth") %>% 
                                 pull(LCounts),5) - LCounts,
                 Counts = rep(bins_hat %>% 
                                filter(Source == "MC" & Treatment == "Truth") %>% 
                                pull(Counts),5) - Counts,
                 Step = "Residuals")) %>%
  mutate(across(Name, factor, 
                levels = c("Unfolded Theory 1 Data",
                           "Unfolded Theory 2 Data",
                           "Unfolded Theory 3 Data",
                           "Unfolded Theory 1 MC",
                           "Unfolded Theory 2 MC")))


asinh_trans <- function(){
  trans_new(name = 'asinh', transform = function(x) asinh(x), 
            inverse = function(x) sinh(x))
}
fancy_scientific <- function(l) {
     # turn in to character string in scientific notation
     l <- format(l, scientific = TRUE)
     # replace 0e+00 with 0
     l <- gsub("0e\\+00","0",l)
     # remove + after exponent, if exists. E.g.: (3x10^+2 -> 3x10^2)
     l <- gsub("e\\+","e",l)
     # turn the 'e+' into plotmath format
     l <- gsub("e", "\\10^", l)
     parse(text=l)
}

ggplot() + 
  theme_bw() +
  geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.5) +
  geom_segment(data = bins_hat %>%
                 filter(Treatment == "TruthHat"&
                          Step == "Residuals"),
               mapping = aes(x = LBin,
                             y = Counts,
                          xend = Bin,
                          yend = Counts,
                         color = `Assumed Theory`),
               alpha = 0.8) +
  geom_segment(data = bins_hat %>%
                 filter(Treatment == "TruthHat"&
                          Step == "Residuals"),
               mapping = aes(x = LBin,
                             y = LCounts,
                          xend = LBin,
                          yend = Counts,
                         color = `Assumed Theory`),
               alpha = 0.8) +
  scale_x_continuous(breaks = seq(0,30,by=3), 
                       limits = c(0,30), 
                       expand = c(0,0)) +
  scale_y_continuous(trans="asinh",
                     breaks = c(-10^(c(6,4,2)),0,10^(c(2,4,6))),
                     labels = fancy_scientific) +
  scale_color_manual(values = c("#5e81b5","#e19c24")) +
  facet_wrap(Name ~ ., ncol = 3) +
  theme(legend.position = c(0.95, 0.1), legend.justification = c(1, 0)) +
  labs(title = expression(Residuals~of~estimated~true~counts~using~pseudoinverses~
                      (widehat(mu)==R^paste("+")*~widehat(nu))), x = "X (Truth)", 
       y = expression(mu~-~widehat(mu)~~(Residuals)))

```

```{r echo = F}

C <- rbind(rep(0,30),cbind(diag(1,29),rep(0,29))) + 
  rbind(cbind(rep(0,29),diag(1,29)),rep(0,30)) +
  diag(c(-1,rep(-2,28),-1)) + diag(10^(-3),30)

A1 <- R_mc1 %*% diag(mcTruth1$Counts)
Ainv1 <- svd(A1)$v %*% solve(diag(svd(A1)$d)) %*% t(svd(A1)$u)

plot(1:30, svd(A1)$d, log="y")

#max(svd(A1)$d)/min(svd(A1)$d)

#svd(A1)$v %*% solve(diag(svd(A1)$d))^2 %*% t(svd(A1)$v)

y1 <- dataReco1$Counts/sqrt(mcReco1$Counts)
#t(svd(A1)$u) %*% y1


B1 <- Vnu1
Q1 <- svd(B1)$u
R1 <- diag(svd(B1)$d)
As1 <- t(t(Q1) %*% solve(R1)) %*% A1
Xinv1 <- diag(0,30)
for(j in 1:30){
  for(k in 1:30){
    Xinv1[j,k] <- (1/prod(mcTruth1$Counts[c(j,k)]))*sum(As1[,j]*As1[,k])
  }
}
bs1 <- diag(solve(R1)) * (Q1 %*% mcReco1$Counts)
U1 <- svd(As1 %*% solve(C))$u
V1 <- svd(As1 %*% solve(C))$v
d <- t(U1) %*% bs1

plot(1:30, abs(d), log="y")
abline(h = sqrt(pi)/2, lty = 2)

plot(1:30,rev(cumsum(rev(abs(d)))/(1:30)),log="y")
abline(h = sqrt(pi)/2, lty = 2)

A2 <- R_mc2 %*% diag(mcTruth2$Counts)
B2 <- Vnu2
Q2 <- svd(B2)$u
R2<- diag(svd(B2)$d)

inv_R_mc1 <- solve(t(R_mc1) %*% solve(Vnu1) %*% R_mc1) %*% t(R_mc1) %*% solve(Vnu1)
inv_R_mc2 <- solve(t(R_mc2) %*% solve(Vnu2) %*% R_mc2) %*% t(R_mc2) %*% solve(Vnu2)

Vmu1 <- inv_R_mc1 %*% Vnu1 %*% t(inv_R_mc1)
Vmu2 <- inv_R_mc2 %*% Vnu2 %*% t(inv_R_mc2)

data1_unfolded_mc1 <- inv_R_mc1 %*% dataReco1$Counts
data1_unfolded_mc2 <- inv_R_mc2 %*% dataReco1$Counts
data2_unfolded_mc1 <- inv_R_mc1 %*% dataReco2$Counts
data2_unfolded_mc2 <- inv_R_mc2 %*% dataReco2$Counts
data3_unfolded_mc1 <- inv_R_mc1 %*% dataReco3$Counts
data3_unfolded_mc2 <- inv_R_mc2 %*% dataReco3$Counts
mc1_unfolded_mc1 <- inv_R_mc1 %*% mcReco1$Counts
mc1_unfolded_mc2 <- inv_R_mc2 %*% mcReco1$Counts
mc2_unfolded_mc1 <- inv_R_mc1 %*% mcReco2$Counts
mc2_unfolded_mc2 <- inv_R_mc2 %*% mcReco2$Counts
```

\section{Algorithm Construction}

Unfolding is ultimately concerned with finding a reliable inverse to the process by which an event occurring in some true bin $i$ maps to an observed bin $j$. In generalizing this a bit we can think in terms of \textit{causes}, $C_i$ ($i=1,\dots,n_C$) and \textit{effects}, $E_j$ ($j=1,\dots,n_E$), representing the true and observed bins respectively. In regard to a single event we are then interested in conditional probabilistic view for causation, $P(C_i\vert E_j,I)\equiv\theta_{ij}$, the probability that we can attribute some cause $C_i$ to an observed effect $E_j$. Using Bayes' theorem we can define this in terms of other probabilities that can be estimated more directly,
\begin{eqnarray}
P(C_i\vert E_j,I) & = & \frac{P(E_j\vert C_i,I)\cdot P(C_i\vert I)}{\sum_{i=1}^{n_C}P(E_j\vert C_i,I)\cdot P(C_i\vert I)}\nonumber\\
\theta_{ij} & = & \frac{\lambda_{ji}\cdot P(C_i\vert I)}{\sum_{i=1}^{n_C}\lambda_{ji}\cdot P(C_i\vert I)},
\end{eqnarray}
where the conditional probability regarding inference (effect), $P(E_j\vert C_i,I)\equiv\lambda_{ji}$, is the probability that some effect $E_j$ will result with some cause $C_i$ and $P_o(C_i\vert I)$ is the true probability of an event occurring from cause $C_i$. The term $I$ represents any implicit conditional information regarding the analysis, such as the choice of prior, and is usually apparent when the probabilities are written out as density functions.

At the analysis level we care less about individual events and more about mapping the total number events per effect, $\bm{x}_E=\{x(E_1),\dots,x(E_{n_E})\}$, to the total number of events per cause, $\bm{x}_C=\{x(C_1),\dots,x(C_{n_C})\}$. However, so far this regards only observed events as categorized into the $n_E$ effects, as we cannot expect to observe or select for all effects resulting from some arbitrary cause $C_i$. In light of this, while we can add causes to account for any independent background sources to assume the normalization of $P_o(C_i\vert E_j,I)$ and $P_o(C_i\vert I)$, such that $\sum_{i=1}^{n_C}P_o(C_i\vert E_j, I)=1$ and $\sum_{i=1}^{n_C}P(C_i\vert I)=1$, we cannot say the same for $P(E_j\vert C_i,I)$. A necessarily imperfect effect selection capability results in 
$$0\leq\sum_{j=1}^{n_E}P(E_j\vert C_i,I)=\sum_{j=1}^{n_E}\lambda_{ji}\equiv\epsilon_i\leq 1,$$ 
the exact value of which provides for us a definition for $\epsilon_i$, the \textit{efficiency} at which we detect cause $C_i$ from all accounted for observed effects, being also defined and useable as the ratio of observed events resulting from cause $C_i$ to the true number of events resulting from $C_i$, $x^{obs}(C_i)/x(C_i)$.

```{r, echo = FALSE, fig.align='center', fig.cap="\\label{c2elinks}\\emph{Thinking of causes and effects as distinct subsets within one or more dimensional cause and effect phase spaces, this figure shows how events are probabilistically mapped from the subsets used to define our causes to the subsets used to define our effects. The node indicated by $T$ (`trash') represents the event selection inefficiency, and can be thought of as an additional effect $E_{n_E+1}$ that contains an unobserved number of events. Unlike the possibility of alloting independent sources of background to different causes, $E_{n_E+1}$ ($\\:T$) can consist of any number of potentially distinguishable effects depending on how the lost events are distributed across the complement of $\\cup(E_1,E_2,\\dots,E_{n_E})$ in our effect phase space.}"}
include_graphics("problinks.png", dpi=275)
```

A visualization of these lost events can be seen in Figure [\ref{c2elinks}], where some collection of undocumented effects resulting from our collection of causes are lumped into a composite effect $E_{n_E+1}$, which should relate to our efficiency regarding cause $C_i$ by $P(E_{n_E+1}\vert C_i,I)=\lambda_{n_E+1,i}=1-\epsilon_i$. Including this new effect with the others results in $\sum_{j=1}^{n_E}\lambda_{ji}=1$, creating normalized basis vectors to define the columns of a \textit{smearing matrix} $\Lambda$, 
\begin{eqnarray}\Lambda
&=&\begin{pmatrix}
  P(E_1\vert C_1,I)       & P(E_1\vert C_2,I)       & \dots  & P(E_1\vert C_{n_C},I)       \\
  P(E_2\vert C_1,I)       & P(E_2\vert C_2,I)       & \cdots & P(E_2\vert C_{n_C},I)       \\
  \vdots                  & \vdots                  & \ddots & \vdots                      \\
  P(E_{n_E}\vert C_1,I) & P(E_{n_E}\vert C_2,I) & \dots  & P(E_{n_E}\vert C_{n_C},I) \\
  P(E_{n_E+1}\vert C_1,I) & P(E_{n_E+1}\vert C_2,I) & \dots  & P(E_{n_E+1}\vert C_{n_C},I)
  \end{pmatrix}\\
&=& (\bm\lambda_1,\bm\lambda_2,\dots,\bm\lambda_{n_c}),\nonumber
\end{eqnarray}
where $\bm\lambda_i$ refers to the $i$-th column consisting of $\{\lambda_{1,i},\lambda_{2,i},\dots,\lambda_{n_E+1,i}\}$.

Now that Eq. (2) accounts for lost events we can begin to construct a conditional probability for $\bm{x}_C$ similar to that for Eq. (1) using Bayes' theorem,
\begin{eqnarray}
P(\bm{x}_C\vert \bm{x}_E,\Lambda,I)\propto P(\bm{x}_E\vert \bm{x}_C,\Lambda,I)\cdot P(\bm{x}_C\vert I),
\end{eqnarray}
and account for uncertainties in $\Lambda$ with
$$P(\bm{x}_C\vert\bm{x}_E,I)=\int P(\bm{x}_C\vert \bm{x}_E,\Lambda,I)\ f(\Lambda\vert I)\ \text{d}\Lambda.$$
At this point one should recognize in Eq. (3) $P(\bm{x}_E\vert \bm{x}_C,\Lambda,I)$ as the likelihood and $P(\bm{x}_C\vert I)$ as the prior in the formal calculation of a posterior. Ignoring the prior for now and focusing on the likelihood, for a given cause $C_i$ we can model this expression as a multinomial distribution such that
\begin{eqnarray}
P(\bm{x}_E\vert x(C_i),\Lambda,I) &=& \frac{x(C_i)!}{\prod_j^{n_E+1}x(E_j)!}\prod_j^{n_E+1}\lambda_{ji}^{x(E_j)},
\end{eqnarray}
which leads us finally to asking how we should estimate our $\lambda_{ji}$'s. Once again, using Bayes' theorem we can see that for a fixed $i$,
\begin{eqnarray}
f(\bm{\lambda}_i\vert \bm{x}_E,x(C_i),I) &\propto& P(\bm{x}_E\vert x(C_i),\bm{\lambda}_i,I)\cdot f(\bm{\lambda}_i\vert I).
\end{eqnarray}
Previously mentioned properties about $\bm\lambda_i$ make a Dirichlet$(\bm\alpha_{prior_i})$ prior appropriate. A flat prior in which $\bm\alpha_{prior_i}=\{1,\dots,1\}$ is often chosen, and is done so here. Regardless of the choice for $\bm\alpha_{prior_i}$, multiplying by a multinomial distribution results in the posterior
\begin{eqnarray}
f(\bm{\lambda}_i\vert \bm{x}_E,x(C_i),I) &\propto& \left[\frac{x(C_i)!}{\prod_j^{n_E+1}x(E_j)!}\prod_j^{n_E+1}\lambda_{ji}^{x(E_j)}\right]\cdot\left[\frac{1}{\text{B}(\bm\alpha_{prior_i})}\prod_{j=1}^{n_E+1}\lambda_{ji}^{\alpha_{prior_{ji}}-1}\right] \nonumber\\
&\propto&\prod_j^{n_E+1}\lambda_{ji}^{\left(\alpha_{prior_{ji}}+x(E_j)\right)-1} \nonumber\\
&=& \text{Dirichlet}(\bm\alpha_{prior_i}+\bm{x}_E).
\end{eqnarray}
Samples from this distribution informs much of the the uncertainty resulting from the unfolding process, creating distributions for objects fully or partially calculated from them, such as the smearing matrix, efficiency, and inverse probabilities $\theta_{ij}$ once a prior for $P(C_i\vert I)$ is made. These will be necessary, as $P(\bm{x}_C\vert\bm{x}_E,I)$ becomes the sum of independent multinomial distributions, which does not have a closed solution that we can analytically maximize the likelihood of. We have to make the rest of our progress starting from Eq. (1) where the choice around a prior for $P(C_i\vert I)$ is due. The choice of $P(C_i\vert I)=constant$ is considered here, which D’Agostini acknowledges is a strong prior that produces biases that will require iterations to be resolved.

Defining $\bm\theta_{j}=\{\theta_{1,j},\theta_{2,j},\dots,\theta_{n_C,j}\}$, we can model how the $x(E_j)$ observed events with the effect $E_j$ are likely distributed from potential causes by the multinomial distribution
$$\bm{x}_C\vert_{x(E_j)}\;\sim\;\text{Mult}(x(E_j),\bm\theta_{j}).$$
Before summing over the effects to get the total observed causes we should acknowledge that each $x(E_j)$ is the result of a Poisson process with an unknown rate parameter $\mu_j$. Using the conjugate prior $\mu_j\;\sim\;\text{Gamma}(c_j,r_j)$, with $c_j=1$ and very small $r_j$ to create a flat prior, we arrive at 
$$\mu_j\vert_{x(E_j)}\;\sim\;\text{Gamma}(c_j+x(E_j),r_j+1),$$
which tells us not to use $x(E_j)$, but $\mu_j$. In dealing with fractional values of $\mu_j$ D’Agostini suggests:
\begin{enumerate}
  \item Rounding $\mu_j$ to its nearest positive integer $m_j$,
  \item Sampling from $\bm{x}_C\vert_{m_j}\;\sim\;\text{Mult}(m_j,\bm\theta_{j})$,
  \item Rescaling by $\bm{x}_C\vert_{\mu_j}=\frac{\mu_j}{m_j}\bm{x}_C\vert_{m_j}$,
  \item Summing over each effect with $\bm{x}_C\vert_{\bm{x}_E}=\sum_{j=1}^{n_E}\bm{x}_C\vert_{\mu_j}$,
  \item And applying the inefficiency correction with $\bm{x}_C=\frac{\bm{x}_C\vert_{\bm{x}_E}}{\epsilon_i}$.
\end{enumerate}
The drawing of multiple samples from the posteriors is used to form an ensemble of values of $\bm{x}_C$ and estimate credible intervals. The performance of second and later iterations is accomplished by using the previous iteration's posteriors as the new iteration's priors. 

\section{A Basic Example}

In the following example 400,000 random samples are drawn from a Cauchy distribution and then subject to some processes that disperse, bias, and reduce event selection efficiency. The results of these simulations are shown in Figure [\ref{exampleUnfold}]. The migration matrix does a decent job of demonstrating how the true data was smeared. For unaffected data one would see just a diagonal line from the bottom left to the top right. It was with this in mind that instead of choosing the earlier mentioned flat prior for $\bm\alpha_{prior_i}$ I decided to go with 
\begin{eqnarray}
  \alpha_{ij} = e^{-\vert x_{truth}-x_{smeared}\vert}\nonumber,
\end{eqnarray}
the values of which are represented in Figure [\ref{prior}].

```{r, fig.height=7.5, fig.align='center', fig.width=5, echo=F, fig.cap="\\label{exampleUnfold}\\emph{TOP: The true and smeared distribution of our toy model. BOTTOM: When considering count data, the smearing matrix is often referred to as the response or migration matrix. The bottom row corresponds to the events that were not assigned to an effect.}", eval = F}
nsim <- 100000

true <- rcauchy(nsim, 0.5, 1)
eff <-  runif(nsim) > 0.2 + (1.0-0.5)/20*(true+10.0)

predicted <- (true + rnorm(nsim, -2.5, 0.2))[eff]
step_hist_notfolded <- hist(true[which(true>-10 & true<10)], 
                           breaks = seq(-10,10,0.5), plot = F)
step_hist_folded <- hist(predicted[which(predicted>-10 & predicted<10)], 
                         breaks = seq(-10,10,0.5), plot = F)


ymax <- 1.075*max(c(step_hist_folded$density,step_hist_notfolded$density))
ymax_count <- 1.1*max(c(step_hist_folded$count,step_hist_notfolded$count))

step_hist <- 
  tibble(binLow = c(step_hist_folded$breaks[-length(step_hist_folded$breaks)],
                    step_hist_notfolded$breaks[-length(step_hist_notfolded$breaks)]),
         binHigh = c(step_hist_folded$breaks[-1],step_hist_notfolded$breaks[-1]),
         CountsL = c(c(0,step_hist_folded$counts[-length(step_hist_folded$counts)]),
                     c(0,step_hist_notfolded$counts[-length(step_hist_notfolded$counts)])),
         Counts = c(step_hist_folded$counts,step_hist_notfolded$counts),
         DensityL = c(c(0,step_hist_folded$density[-length(step_hist_folded$density)]),
                      c(0,step_hist_notfolded$density[-length(step_hist_notfolded$density)])),
         Density = c(step_hist_folded$density,step_hist_notfolded$density),
         Treatment = c(rep("smeared", length(step_hist_folded$density)),
                       rep("truth", length(step_hist_notfolded$density))))

dists <- ggplot(data = step_hist) + 
  theme_bw() +
  geom_segment(mapping = aes(x = binLow,
                             y = Counts,
                          xend = binHigh,
                          yend = Counts,
                          color = Treatment),
               alpha=0.6) +
  geom_segment(mapping = aes(x = binLow,
                             y = CountsL,
                          xend = binLow,
                          yend = Counts,
                          color = Treatment), 
               alpha=0.6) +
  scale_x_continuous(breaks = seq(-10,10,2), 
                     limits = c(-10,10), 
                     expand = c(0,0)) +
  scale_y_continuous("Counts", limits = c(0,ymax_count), expand = c(0,0),
                     breaks = seq(0,ceiling(ymax_count), ceiling(ymax_count/1000)*100)) +
  labs(x="X", y="", title=element_blank()) +
  scale_color_manual(values=c("red","blue")) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())

rf <- colorRampPalette(rev(brewer.pal(11,'Spectral')))
r <- rf(32)
 
smear <- tibble(`True X` = c(true[eff],true[-eff]),
                `Observed X` = c(predicted,rep(-10.249999999,length(true[-eff]))))

smear_m <- ggplot(filter(smear, `True X` <= 10 & `Observed X` <= 10, `True X` >= -10 & 
                           (`Observed X` >= -10 | `Observed X` == -10.249999999))) +
  scale_x_continuous(breaks = seq(-10,10,2), 
                     limits = c(-10,10), 
                     expand = c(0,0)) +
  scale_y_continuous(breaks = seq(-12,10,2), 
                     limits = c(-10.5,10), 
                     expand = c(0,0)) +
  theme_bw() + theme(panel.grid.major = element_blank(), 
                     panel.grid.minor = element_blank()) +
  scale_fill_gradientn(colours=r, breaks=seq(0,12000,2000)) +
  stat_bin2d(mapping=aes(x=`True X`, y=`Observed X`), 
             breaks = list(x=seq(-10,10,0.5),
                           y=seq(-10.5,10,0.5))) +
  geom_abline(slope = 0,intercept = -10,lty=2)

grid.arrange(dists, smear_m, nrow=2)
```

```{r, fig.height=3.75, fig.align='center', fig.width=4.5, echo=F, fig.cap="\\label{prior}\\emph{Instead of choosing a flat prior Dirichlet($\\bm\\alpha_{prior_i}$) in which $\\bm\\alpha_{prior_i}=\\{1,\\dots,1\\}$, I opted for one that assumed a dominant diagonal signal, corresponding to a max value of alpha along the diagonal that decays exponentially the further you get from the diagonal.}", eval = F}
test <- tibble(x = rep(seq(-9.5,9.5,1),20),
               y = rep(seq(-9.5,9.5,1),each=20))
test$scale <- exp(-abs(test$x-test$y))

rf <- colorRampPalette(rev(brewer.pal(11,'Spectral')))
r <- rf(40)
ggplot(test) +
  scale_x_continuous(breaks = seq(-10,10,2), 
                     limits = c(-10,10), 
                     expand = c(0,0)) +
  scale_y_continuous(breaks = seq(-10,10,2), 
                     limits = c(-10,10), 
                     expand = c(0,0)) +
  theme_bw() + theme(panel.grid.major = element_blank(), 
                     panel.grid.minor = element_blank()) +
  labs(x="True X", y="Observed X", title=expression(alpha ~"values for prior")) +
  scale_fill_gradientn(colours=r, breaks=seq(0,1,0.2)) +
  geom_tile(mapping=aes(x=x, y=y, fill=scale))
```


```{r, echo = F, eval = F}     
# Number of "causes" and "effects"
nc <- ne <-  40

# Get migration counts from stored ggplot and create smearing matrix
smear_data <- ggplot_build(smear_m)$data[[1]]
smearing_matrix <- matrix(rep(0,nc*(ne+1)), ncol = nc)
for( i in 1:nrow(smear_data)){
  smearing_matrix[cbind(smear_data$xbin, (ne+2)-smear_data$ybin)[i,2],
                  cbind(smear_data$xbin, (ne+2)-smear_data$ybin)[i,1]] <- smear_data$value[i]
}
smearing_matrix_normcols <- smearing_matrix / 
  matrix(rep(apply(smearing_matrix, MARGIN = 2, sum),ne+1), nrow=ne+1, byrow = T)

# Get observed number of events per effect
xE1 <- smearing_matrix %*% rep(1,nc)

# Number of samples drawn from each posterior distribution
nsamp <- 10
Lamb1 <- theta1 <- invMig1 <- list(NA)
xC1 <- efficiency1 <- mu1 <- intmu1 <- matrix(rep(NA,nsamp*nc), ncol=nsamp)
for(i in 1:nsamp){
  # New smearing matrices sampled from Dirichlet posterior
  Lamb1[[i]] <- matrix(unlist(map(1:nc, ~ t(rdirichlet(1, exp(-abs(.-1:(ne+1)))+
                                                             smearing_matrix[,.])))), nrow=ne+1)
  # Efficiencies calculated for each 
  efficiency1[,i] <- apply(Lamb1[[i]][-(ne+1),], MARGIN = 2, sum)
  # Apply Bayes' theorem to get P(C|E)
  theta1[[i]] <- t(Lamb1[[i]][-(ne+1),]/(matrix(rep(apply(Lamb1[[i]][-(ne+1),],
                                                          MARGIN = 1, sum), nc), ncol=nc)))
  mu1[,i] <- map_dbl(xE1[-(ne+1)], ~ rgamma(1,1+.,1))
  intmu1[,i] <- round(mu1[,i])
  intmu1[,i][which(intmu1[,i]==0)] <- 1
  invMig1[[i]] <- matrix(unlist(map(1:ne, ~ rmultinom(n=1,size=intmu1[.,i], 
                                                     prob=theta1[[i]][,.]))),nrow=ne)
  xC1[,i] <- (apply(invMig1[[i]],MARGIN=1, sum)/
                efficiency1[,i])*(mu1[,i]/intmu1[,i])
}

step_hist$barlow <- rep(0,nc+ne)
step_hist$barhigh <- rep(0,nc+ne)

step <- filter(step_hist, Treatment == "truth")
step$Counts <- apply(xC1, MARGIN=1, mean)
step$CountsL[-1] <- apply(xC1, MARGIN=1, mean)[-nc]
step$Treatment <- "1 iteration"
step$Density <- apply(xC1, MARGIN=1, mean)/sum(apply(xC1, MARGIN=1, mean))
step$DensityL[-1] <- step$Density[-nc]
step$barlow <- apply(xC1, MARGIN=1, FUN=quantile, probs=0.025)
step$barhigh <- apply(xC1, MARGIN=1, FUN=quantile, probs=0.975)
step_hist_iter1 <- rbind(step_hist,step)

ymax_count <- 1.1*max(step_hist_iter1$Counts)

it1 <- ggplot(data = step_hist_iter1) + 
  theme_bw() +
  geom_rect(mapping = aes(xmin = binLow,
                          ymin = barlow,
                          xmax = binHigh,
                          ymax = barhigh,
                          fill = Treatment),
            alpha=0.2) +
  geom_segment(mapping = aes(x = binLow,
                             y = Counts,
                          xend = binHigh,
                          yend = Counts,
                          color = Treatment),
               alpha=0.7) +
  geom_segment(mapping = aes(x = binLow,
                             y = CountsL,
                          xend = binLow,
                          yend = Counts,
                          color = Treatment), 
               alpha=0.7) +
  scale_x_continuous(breaks = seq(-10,10,2), 
                     limits = c(-10,10), 
                     expand = c(0,0)) +
  scale_y_continuous("Counts", limits = c(0,ymax_count), expand = c(0,0),
                     breaks = seq(0,ceiling(ymax_count), ceiling(ymax_count/1000)*100)) +
  labs(x="X", y="", title="1 Iteration") +
  scale_color_manual(values=c("orange","red","blue")) +
  scale_fill_manual(values=c("orange","red","blue")) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
```

```{r, echo = F, eval = F}
# Get observed number of events per effect
xE2 <- xC1

# Number of samples drawn from posterior distribution
Lamb2 <- efficiency2 <- theta2 <- invMig2 <- list(NA)
xC2 <- efficiency2 <- mu2 <- intmu2 <- matrix(rep(NA,nsamp*nsamp*nc), ncol=nsamp*nsamp)
for(i in 1:nsamp){
  for(j in 1:nsamp){
    # New smearing matrices sampled from Dirichlet posterior
    Lamb2[[(i-1)*nsamp+j]] <- 
      matrix(unlist(map(1:nc, ~ t(rdirichlet(1,exp(-abs(.-1:(ne+1)))+smearing_matrix[,.]+c(invMig1[[i]][.,],0))))), 
             nrow=ne+1)
    # Efficiencies calculated for each 
    efficiency2[,(i-1)*nsamp+j] <- apply(Lamb2[[(i-1)*nsamp+j]][-(ne+1),],MARGIN=2, sum)
    # Apply Bayes' theorem to get P(C|E)
    theta2[[(i-1)*nsamp+j]] <- t((Lamb2[[(i-1)*nsamp+j]][-(ne+1),]*matrix(rep(xC1[,i], nc),byrow=T,ncol=nc))/
                                (matrix(rep(Lamb2[[(i-1)*nsamp+j]][-(ne+1),] %*% 
                                              xC1[,i], nc), ncol=nc)))
  
    mu2[,(i-1)*nsamp+j] <- map_dbl(1:ne, ~ rgamma(1,1+xE1[.]+xE2[.,j],2))
    intmu2[,(i-1)*nsamp+j] <- round(mu2[,(i-1)*nsamp+j])
    intmu2[,(i-1)*nsamp+j][which(intmu2[,(i-1)*nsamp+j]==0)] <- 1
    invMig2[[(i-1)*nsamp+j]] <- matrix(unlist(map(1:ne,~rmultinom(n=1,size=intmu2[.,(i-1)*nsamp+j], 
                                                                  prob=theta2[[(i-1)*nsamp+j]][,.]))),nrow=ne)
    xC2[,(i-1)*nsamp+j] <- (apply(invMig2[[(i-1)*nsamp+j]],MARGIN=1,sum)/efficiency2[,(i-1)*nsamp+j])*
      (mu2[,(i-1)*nsamp+j]/intmu2[,(i-1)*nsamp+j])
  }
}

step <- filter(step_hist, Treatment == "truth")
step$Counts <- apply(xC2, MARGIN=1, mean)
step$CountsL[-1] <- apply(xC2, MARGIN=1, mean)[-nc]
step$Treatment <- "2 iterations"
step$Density <- apply(xC2, MARGIN=1, mean)/sum(apply(xC2, MARGIN=1, mean))
step$DensityL[-1] <- step$Density[-nc]
step$barlow <- apply(xC2, MARGIN=1, FUN=quantile, probs=0.025)
step$barhigh <- apply(xC2, MARGIN=1, FUN=quantile, probs=0.975)
step_hist_iter2 <- rbind(step_hist,step)

ymax_count <- 1.1*max(step_hist_iter2$Counts,step_hist_iter2$barhigh)

it2 <- ggplot(data = step_hist_iter2) + 
  theme_bw() +
  geom_rect(mapping = aes(xmin = binLow,
                          ymin = barlow,
                          xmax = binHigh,
                          ymax = barhigh,
                          fill = Treatment),
            alpha=0.2) +
  geom_segment(mapping = aes(x = binLow,
                             y = Counts,
                          xend = binHigh,
                          yend = Counts,
                          color = Treatment),
               alpha=0.7) +
  geom_segment(mapping = aes(x = binLow,
                             y = CountsL,
                          xend = binLow,
                          yend = Counts,
                          color = Treatment), 
               alpha=0.7) +
  scale_x_continuous(breaks = seq(-10,10,2), 
                     limits = c(-10,10), 
                     expand = c(0,0)) +
  scale_y_continuous("Counts", limits = c(0,ymax_count), expand = c(0,0),
                     breaks = seq(0,ceiling(ymax_count), ceiling(ymax_count/1000)*100)) +
  labs(x="X", y="", title="2 Iterations") +
  scale_color_manual(values=c("orange","red","blue")) +
  scale_fill_manual(values=c("orange","red","blue")) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
```

```{r, echo = F, warning=F, eval = F}
# Get observed number of events per effect
xE3 <- xC2

# Number of samples drawn from posterior distribution
Lamb3 <- efficiency3 <- theta3 <- invMig3 <- list(NA)
xC3 <- efficiency3 <- mu3 <- intmu3 <- matrix(rep(NA,nc*nsamp^3), ncol=nsamp^3)
for(i in 1:nsamp){
  for(j in 1:nsamp){
    for(k in 1:nsamp){
      # New smearing matrices sampled from Dirichlet posterior
      Lamb3[[(i-1)*nsamp^2+(j-1)*nsamp+k]] <- 
        matrix(unlist(map(1:nc, ~ t(rdirichlet(1,exp(-abs(.-1:(ne+1)))+smearing_matrix[,.]+
                                                 c(invMig1[[i]][.,],0)+c(invMig2[[(j-1)*nsamp+k]][.,],0))))), 
               nrow=ne+1)
      # Efficiencies calculated for each 
      efficiency3[,(i-1)*nsamp^2+(j-1)*nsamp+k] <- 
        apply(Lamb3[[(i-1)*nsamp^2+(j-1)*nsamp+k]][-(ne+1),],MARGIN=2, sum)
      # Apply Bayes' theorem to get P(C|E)
      theta3[[(i-1)*nsamp^2+(j-1)*nsamp+k]] <- 
        t((Lamb3[[(i-1)*nsamp^2+(j-1)*nsamp+k]][-(ne+1),]*
             matrix(rep(xC3[,(j-1)*nsamp+k], nc),byrow=T,ncol=nc))/
            (matrix(rep(Lamb3[[(i-1)*nsamp^2+(j-1)*nsamp+k]][-(ne+1),] %*% 
                          xC3[,(j-1)*nsamp+k], nc), ncol=nc)))
    
      mu3[,(i-1)*nsamp^2+(j-1)*nsamp+k] <- 
        map_dbl(1:ne, ~ rgamma(1,1+xE1[.]+xE2[.,k]+xE3[(j-1)*nsamp+k],3))
      intmu3[,(i-1)*nsamp^2+(j-1)*nsamp+k] <- 
        round(mu3[,(i-1)*nsamp^2+(j-1)*nsamp+k])
      intmu3[,(i-1)*nsamp^2+(j-1)*nsamp+k][which(intmu3[,(i-1)*nsamp^2+(j-1)*nsamp+k]==0)] <- 1
      invMig3[[(i-1)*nsamp^2+(j-1)*nsamp+k]] <- 
        matrix(unlist(map(1:ne,~rmultinom(n=1,size=intmu3[.,(i-1)*nsamp^2+(j-1)*nsamp+k], 
                                          prob=theta2[[(i-1)*nsamp+j]][,.]))),nrow=ne)
      xC3[,(i-1)*nsamp^2+(j-1)*nsamp+k] <- 
        (apply(invMig3[[(i-1)*nsamp^2+(j-1)*nsamp+k]],MARGIN=1,sum)/efficiency3[,(i-1)*nsamp^2+(j-1)*nsamp+k])*
        (mu3[,(i-1)*nsamp^2+(j-1)*nsamp+k]/intmu3[,(i-1)*nsamp^2+(j-1)*nsamp+k])
    }
  }
}

step <- filter(step_hist_iter1, Treatment == "truth")
step$Counts <- apply(xC3, MARGIN=1, mean)
step$CountsL[-1] <- apply(xC3, MARGIN=1, mean)[-nc]
step$Treatment <- "3 iterations"
step$Density <- apply(xC3, MARGIN=1, mean)/sum(apply(xC3, MARGIN=1, mean))
step$DensityL[-1] <- step$Density[-nc]
step$barlow <- apply(xC3, MARGIN=1, FUN=quantile, probs=0.025)
step$barhigh <- apply(xC3, MARGIN=1, FUN=quantile, probs=0.975)
step_hist_iter3 <- rbind(step_hist,step)

ymax_count <- 1.1*max(step_hist_iter3$Counts,step_hist_iter2$barhigh)

it3 <- ggplot(data = step_hist_iter3) + 
  theme_bw() +
  geom_rect(mapping = aes(xmin = binLow,
                          ymin = barlow,
                          xmax = binHigh,
                          ymax = barhigh,
                          fill = Treatment),
            alpha=0.2) +
  geom_segment(mapping = aes(x = binLow,
                             y = Counts,
                          xend = binHigh,
                          yend = Counts,
                          color = Treatment),
               alpha=0.7) +
  geom_segment(mapping = aes(x = binLow,
                             y = CountsL,
                          xend = binLow,
                          yend = Counts,
                          color = Treatment), 
               alpha=0.7) +
  scale_x_continuous(breaks = seq(-10,10,2), 
                     limits = c(-10,10), 
                     expand = c(0,0)) +
  scale_y_continuous("Counts", limits = c(0,ymax_count), expand = c(0,0),
                     breaks = seq(0,ceiling(ymax_count), ceiling(ymax_count/1000)*100)) +
  labs(x="X", y="", title="3 Iterations") +
  scale_color_manual(values=c("orange","red","blue")) +
  scale_fill_manual(values=c("orange","red","blue")) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
```
\section{Discussion of Results and Conclusion}
The results of my unfolding are shown below in Figure [\ref{iterations}]. The iterations get off to an okay start, but instead of converging they begin to behave erratically. The tails blowing up clearly comes from using random samples from a posterior distribution as basis for new priors, embedding events in places where there were zero before. I attempted to remedy this with a prior that disfavored events occurring far from the diagonal, as mentioned previously in the context of Figure [\ref{prior}]. It kept these tails from blowing up for at least the first iteration. In the future I will look more into options relating to this issue.

There is almost certainly an error in the code governing the 3rd iteration, resulting in a vastly larger confidence band. Instead of trying to fix this issue I think it would be better use of my time to study some similar working examples \cite{Burgard2021}.

```{r, fig.height=8, fig.align='center', warning=F, fig.width=4.5, echo=F, fig.cap="\\label{iterations}\\emph{The first iteration looks like itd heading the right direction. It is my belief that I have an error somehwere in my work.}", eval = F}
grid.arrange(it1,it2,it3, nrow=3)
```

\newpage

\appendix

\section{Supplementary Mathematical Definitions and Derivations}

\subsection{Hilbert Spaces}\label{appHilbert}

Hilbert spaces are a major structural component of the field of functional analysis. They see significant application in partial differential equations, quantum mechanics, and signal processing, where they are commonly implemented in the performance of Fourier analysis. Mathematically they represent an extension beyond the real and complex geometric-like vector spaces developed by earlier generalizations of Euclidean spaces in the 19th century. Developments in real analysis at the beginning of the 20th century lead the spaces of functions and sequences to being conceptualized as linear spaces in their own right.

As extensions of previously understood spaces they necessarily exist at the intersection of several other important spaces that aught to be understood beforehand. With that said, the following definitions come from Rudin in \cite{Rudin1991}. 
To start, a \textbf{vector space}, as defined here, consists of a set $X$ of vectors for which addition and scalar multiplication are defined such that for all $x,y,z\in X$ and any complex number $\alpha\in\mathbb{C}$
\begin{enumerate}
  \item there exists a vector in $X$ such that
    \begin{enumerate}
      \item addition is commutative: $x+y=y+x$,
      \item addition is associative: $x+(y+z)=(x+y)+z$,
    \end{enumerate}
  \item $\alpha x$ exists in $X$ such that $1x=x$, $0x=0$ (the zero vector), and multiplication is distributive:
    \begin{enumerate}
      \item $\alpha(\beta x)=(\alpha\beta x)$,
      \item $\alpha(x+y)=\alpha x+\alpha y$, and
      \item $(\alpha +\beta)x=\alpha x+\beta x$.
    \end{enumerate}
\end{enumerate}
The range of $\alpha$ above describes a complex vector space. If $\alpha$ is restricted to the reals $\mathbb{R}$, then $X$ is considered a real vector space. Note that vector spaces include more than just traditional coordinate-style vectors, but also include function spaces such as the vector space of all polynomials with degree of at most $n$, which has the basis $\{1,x,x^2,\dots,x^{n-1},x^n\}$.

Typically associated in applications, metric spaces form a another relevant set of spaces that has some significant overlap with the vector spaces. A space $X$ is said to be a \textbf{metric space} if for all $x,y\in X$ there exists an operator $d(x,y)$ that maps them to a nonnegative real number that defines their distance from each other within $X$. The properties of this operator are
\begin{enumerate}
  \item $0\leq d(x,y)<\infty$ for all $x$ and $y\in X$,
  \item $d(x,y)=0$ iff $x=y$,
  \item $d(x,y)=d(y,x)$ for all $x$ and $y\in X$,
  \item $d(x,z)\leq d(x,y)+d(y,z)$ for all $x$, $y$, $z\in X$.
\end{enumerate}
For a metric space $X$, the distance operator $d$ is referred to as the metric on $X$. The intersection of the vector and metric spaces form the set of normed spaces. As an extension of the conditions thus far, a space $X$ is a \textbf{normed space} if $\forall x\in X$ there exists a nonnegative real number $\vert\vert x\vert\vert$, called the \textbf{norm} of $x$ such that
\begin{enumerate}
  \item $\vert\vert x+y\vert\vert\leq\vert\vert x\vert\vert+\vert\vert y\vert\vert\;\forall x,y\in X$,
  \item $\vert\vert\alpha x\vert\vert = \vert\alpha\vert\,\vert\vert x\vert\vert$ if $x\in X$ and $\alpha$ is a scalar,
  \item $\vert\vert x\vert\vert>0$ if $x\neq 0$.
\end{enumerate} 
Such a set is said to be \textbf{complete} if every \textbf{Cauchy sequence} in $X$ converges to a point in $X$. A Cauchy sequence in a metric space $X$ is any sequence $\{x_n\}$ that $\forall\varepsilon>0$ there exists an integer $N$ such that $d(x_m,x_n)<\varepsilon$ when $m>N$ and $n>N$. A quick example of this is the sequence defined by $x_n=\sqrt{n}$. For some starting $x_m$ and $x_n$ where $m-n=\delta$, we have
\begin{align}
d(x_m,x_n)
  &=\sqrt{m}-\sqrt{n}\nonumber\\
  &=\sqrt{n+\delta}-\sqrt{n}\nonumber\\
  &=(\sqrt{n+\delta}-\sqrt{n})\frac{\sqrt{n+\delta}+\sqrt{n}}{\sqrt{n+\delta}+\sqrt{n}}\nonumber\\
  &=\frac{n+\delta-n}{\sqrt{n+\delta}+\sqrt{n}}\nonumber\\
  &=\frac{\delta}{\sqrt{n}(\sqrt{1+\delta/n}+\sqrt{1})}\nonumber\\
  &<\frac{1}{\sqrt{n}}\left(\frac{\delta}{2}\right)<\varepsilon\nonumber\\
  \implies n &> \left(\frac{\delta}{2\varepsilon}\right)^2.\nonumber
\end{align}
Noting that for constant $\delta$ the limit of $\frac{1}{\sqrt{n}}\left(\frac{\delta}{2}\right)$ as $n\longrightarrow\infty$ is the zero vector (the point of convergence) would also be sufficient to show that $x_n=\sqrt{n}$ is a Cauchy sequence.

\begin{wrapfigure}{r}{0.55\textwidth}
  \centering
```{r, echo=F, fig.height=3.6, fig.width=3.6, fig.align='center'}
venndiagram <- tibble(X0 = c( 0.0,0.0,
                             -1.3,0.9),
                      Y0 = c(-0.75, 0.75,
                              0.00,-1.05),
                      R = c(4.50,4.5,
                            2.75,2.3),
                      space = c("Vector Space",
                                "Metric Space",
                                "Inner Product Space",
                                "Banach Space")) %>%
  mutate(across(space, factor, 
                levels = c("Vector Space",
                           "Metric Space",
                           "Inner Product Space",
                           "Banach Space")))
venntext <- tibble(X = c(0.0, 1.90,
                         0.0,-2.25,
                         1.7, 0.00),
                   Y = c( 4.45, 2.10,
                         -4.45, 0.75,
                         -1.70,-0.60),
                   theta = c( 0,-35,
                              0, 50,
                             55,  0),
                   text = c("Vector Space\n(vectors)",
                            "Normed Space\n(length)",
                            "Metric Space\n(distance)", 
                            "Inner Product\nSpace\n(angle/orthogonality)",
                            "Banach Space\n(completeness)",
                            "Hilbert\nSpace"))
                           

ggplot() +
  coord_fixed() + theme_void() +
  geom_circle(data = venndiagram,
              mapping = aes(x0 = X0, y0 = Y0, r = R,
                            fill = space)) +
  geom_text(data = venntext,
            mapping = aes(x = X, y = Y, angle = theta,
                          label = text), size = 3.5) +
  theme(legend.position = "none") +
  scale_fill_manual(values = c(alpha("#b91500",0.35),
                               alpha("#45a500",0.35),
                               alpha("#ef6800",0.25),
                               alpha("#0000e0",0.25)))
  
```
  \caption{\emph{A Venn diagram representing the intersection and nesting of the spaces described in Appendix \ref{appHilbert}.}}
  \label{spaceVenn}
  \vspace{-30pt}
\end{wrapfigure}
Incidentally, a normed vector space that is complete as defined here meets the definition of a \textbf{Banach space}. An additional subset of the normed vector spaces consists of those spaces in which for all $x,y\in X$ there exists a real or complex number $\langle x,y\rangle$ defined by an operator called the \textbf{inner product}. For all $x,y,z\in X$ this operation must satisfy
\begin{enumerate}
  \item $\langle x,y\rangle=\langle y,x\rangle^*$ (where the ${}^*$ represents the complex conjugate),
  \item $\langle x+y,z\rangle=\langle x,z\rangle+\langle y,z\rangle$,
  \item $\langle \alpha x,y\rangle=\alpha\langle x,y\rangle$ (for $\alpha\in\mathbb{C}$),
  \item $\langle x,x\rangle\geq0$, and
  \item $\langle x,x\rangle=0$ iff $x=0$.
\end{enumerate}
A space that satisfies these requirements forms an \textbf{inner product space}, and the inner product defined in such a space relates to the form of its norm, such that $\vert\vert x\vert\vert=\langle x,x\rangle^{1/2}$. Finally, at the intersection of Banach spaces and inner product spaces are the Hilbert spaces. I.e. a \textbf{Hilbert space} is a complete vector space with an inner product defined by its norm.

A commonly presented example is the $L^2$ function space, which consists of functions that are square integrable, i.e. if $f(x)\in L^2\implies \vert\vert f(x)\vert\vert^2=\int_\chi\vert  f(x)\vert^2dx<\infty$, where $\chi$ is the domain of $x$. The subset $L^2[-\pi,\pi]$, where $\chi=[-\pi,\pi]$, has the well known Fourier series as a basis, which is commonly written such that for $f(x)\in L^2[-\pi,\pi]$
\begin{align}
  f(x)=\frac{a_0}{2} + \sum_{n=1}^\infty\left[a_n\cos(nx)+b_n\sin(nx)\right],\nonumber
\end{align}
where
$$\begin{matrix}
  a_n=\frac{1}{\pi}\int_{-\pi}^\pi f(x)\cos(nx)dx \\ \text{and} \\ b_n=\frac{1}{\pi}\int_{-\pi}^\pi f(x)\sin(nx)dx.
\end{matrix}$$
Verification that this basis meets all the requirements laid out so far is beyond the scope of this paper.

\section{R Code}
